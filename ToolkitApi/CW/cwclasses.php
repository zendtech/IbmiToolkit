<?php 
// cwclasses.php: classes for Compatibility Wrapper for IBM i Toolkit for PHP

// toolkit path should be defined in PHP.INI: /usr/local/zendsvr/share/ToolkitApi

require_once 'ToolkitService.php';
require_once 'iToolkitService.php';
require_once 'ToolkitServiceParameter.php';
require_once 'CW/cwconstants.php';

/**
 * ToolkitServiceCw extends the standard Zend/PHP wrapper
 *                  with specific Compatibility Wrapper (CW) features.
 * @author aseiden
 */
class ToolkitServiceCw extends ToolkitService 
{
	protected $error = '';
	protected $joblog = '';
    protected $_privateConnNum = null;
    protected $_isNewConn = true; // default to "new/true" because it's safest. new means app perhaps should initalize job.
	// In case of error, look for CPFs generated by specific other programs.
    // E.g. if userid is wrong when calling QSYGETPH, the CPF may be reported by program QSYPHDL in joblog.
    // TODO would be better specified in external file or in INI.
    protected $_cpfMapping = array('QSYRUSRI' => array('QLIROHDL'),
                                   'QSYGETPH' => array('QSYPHDL'));
    
	static $instance = null;
	
    public function __construct($database, $userOrI5NamingFlag, $password, $extensionPrefix, $isPersistent = false) 
    {
       parent::__construct($database, $userOrI5NamingFlag, $password, $extensionPrefix, $isPersistent);
      
    } //(__construct())

    // need to define this so we get Cw object and not parent object
    static function getInstance($databaseNameOrResource = '*LOCAL', $userOrI5NamingFlag = '', $password = '', $extensionPrefix = '', $isPersistent = false)
	{
	    // if instance hasn't been created yet, create one
		if(self::$instance == NULL){
			$toolkitService = __CLASS__;
			self::$instance=new $toolkitService($databaseNameOrResource, $userOrI5NamingFlag, $password, $extensionPrefix, $isPersistent);		
		}
        if (self::$instance) {
        	// instance exists
        	return self::$instance;
        } else {
        	// some problem
        	setError(I5_ERR_NOTCONNECTED, I5_CAT_PHP, 'Cannot get a connection', 'Cannot get a connection');
        	return false;
        } //(if (parent::$instance))
	} //(getInstance)

	/**
	 * Return true if an instance of this object has already been created.
	 * Return false if no instance has been instantiated.
	 * 
	 * Same as the method in ToolkitService.php.
	 * Cwclasses has its own instance variable so we need this method here, too.
	 * 
	 * Useful when users need to know if a "toolkit connection" has already been made.
	 * Usage:
	 * $isConnected = ToolkitService::hasInstance();
	 * 
	 * @return boolean
	 */
	static function hasInstance() {

		if (isset(self::$instance) && is_object(self::$instance)) {
		    return true;	
		} else {
			return false;
		}
		
	} //(hasInstance())

	
	
	/**
	 * Return version number of the CW.
	 * @return string  Version number (e.g. '1.1.2')
	 */
	static function getVersion() {
	    return CW_VERSION; // from cwconstants.php	
	}

	public function setPrivateConnNum($num) {
		$this->_privateConnNum = $num;
	} //(setPrivateConnNum)
	
	public function getPrivateConnNum() {
		return $this->_privateConnNum;
	} //(setPrivateConnNum)
	
	// establish whether the connection is new or not. Used by i5_get_property()l
	public function setIsNewConn($isNew = true) {
		$this->_isNewConn = $isNew;
	} //(setPrivateConnNum)
	
	public function isNewConn() {
		return $this->_isNewConn;
	} //(setPrivateConnNum)
	
	
	/* overridden PgmCall from ToolkitService
	 * @param array|string  InputParam  An array of ProgramParameter objects OR XML representing params, to be sent as-is.
	 * @param ProgramParameter ReturnValue
	 * @see ToolkitService::PgmCall()
	 */
	public function PgmCall($pgmname, $lib,
	                        $InputParam =  NULL,
							$ReturnValue = NULL, 
							$options = NULL ) 
	{

		$this->cpfErr = '';
		$this->error = '';
		$this->joblog = '';
		$disconnect  = false;
	    $optional  = false;
		$function = NULL;
		$this->XMLWrapper = new XMLWrapper( array('encoding'       => $this->encoding, 
	                                              'convertToCcsid' => $this->convertToCcsid),
		                                    $this);	
			
		$ReturnValueArray = ProgramParameter::ParametersToArray($ReturnValue);
		
		if( strcmp ( $pgmname, "OFF" ) === 0){
			$disconnect = true;
		}		
	
	    if( strcmp ( $pgmname, "NONE" ) === 0){
			$optional = true;
		}
		
		$OutputParamArray = false;	
		
		if( isset($options['func']))/*call service program*/
		    $function = $options['func'];
		    
		if( $disconnect || $optional) {
	
			$InputXML = $this->XMLWrapper->disconnectXMLIn();			
		}
		else {
			$InputXML = $this->XMLWrapper->buildXmlInCw ($InputParam,
													   $ReturnValueArray,
										               $pgmname, $lib, $function );				    
		}	
		
		$OutputXML = $this->ExecuteProgram(  $InputXML, $disconnect);
	
		// there's some output, even if only an error
        if ($OutputXML != '') {
			           
				// see if real data came back
			$OutputParamArray = $this->XMLWrapper->getParamsFromXmlCw( $OutputXML );
			if( is_array($OutputParamArray )){			 
	
				// Extract return values, if available.
				if(isset($ReturnValueArray )){
					$this->updateRetValueArray($OutputParamArray, $ReturnValueArray);	
				}

			} else {
				
				// No real data. Look for errors. Retrieve details from joblog.
				$this->joblog = $this->XMLWrapper->getLastJoblog();
				    				
				// get CPF messages
				// Also store full msg in toolkit log
					
				// include called program in list of pgms that might have generated a CPF error
		        $programsToLookFor = array($pgmname); // make $pgmname the first item in the array
	 
				if (isset($this->_cpfMapping[$pgmname])) {
			        /* list of programs, in addition to the program that was called directly,
			         * that might generate CPF codes in joblog.
		            */
				    // add them to the mix
					// use array_merge because it discards indexes
					$programsToLookFor = array_merge($programsToLookFor, $this->_cpfMapping[$pgmname]);
 
				} //(if other cpf-making programs)
	
				// put values in $this->cpfErr and $this->error
	            $gotErrors = $this->extractErrorFromJoblog($programsToLookFor);            
		            
			} //(if( is_array($OutputParamArray )))
			
			
		    // if got real parms back
         } //(if($OutputXML != ''))
			
		
		 unset ( $this->XMLWrapper );
		 /*output array includes as parmeters as return values.*/				
		 return $OutputParamArray;
			 	
	} //(function pgmCall)
	

	// __toString will help people accustomed to outputting a resource as string
	// and for testing
    public function __toString()
    {
    	$ipc = trim($this->getInternalKey());
    	$serviceLibrary = $this->getToolkitServiceParam('XMLServiceLib');
    	$stringStart = "ToolkitServiceCw object using service library $serviceLibrary.";
    	$ipcInfo = ($ipc) ? "Internalkey: '$ipc'" : "Running stateless (inline, no IPC).";

    	return "$stringStart $ipcInfo";
    	
    } //(__toString)

    // when script ends, non-persistent connection should close
    public function __destruct()
    {	
	/* call to disconnect()  function to down connection */

    	
    	// if connection is in a separate job and nonpersistent, end job
        if (!$this->stateless && !$this->getIsPersistent()) { 
        	$this->disconnect();   	
        } 
        // parent destruct clears the object
        parent::__destruct();
			
	} //(__destruct)

	
	
	/**
	 * Get the most recent system error code, if available.
	 * TODO this may not work because CPFs are done at a class level (data areas etc.) 
	 */
	public function getCPFErr()
	{
		// TODO get from Verify_CPFError or the other one
		return $this->CPFErr;
	}

	
		    /**
     * After calling a program or command, we can export output as variables.
     * This method creates an array that can later be extracted into variables.
     * param array $outputDesc   Format of output params 'CODE'=>'CODEvar' where the value becomes a PHP var name
     * param array $outputValues     Optional. Array of output values to export
     * @return boolean  true on success, false on some error
     */
    public function setOutputVarsToExport(array $outputDesc, array $outputValues) {

      // for each piece of output, export it according to var name given in $outputDesc.
        if ($outputValues && is_array($outputValues) && count($outputValues)) {
        	
        	// initialize
        	$this->_outputVarsToExport = array();
        	
        	foreach ($outputValues as $paramName=>$value) {
                if (isset($outputDesc[$paramName])) {
                    $variableNameToExport = $outputDesc[$paramName];
                    // create the global variable named by $ varName.
                    
                    $GLOBALS[$variableNameToExport] = $value;
                    
                    $this->_outputVarsToExport[$variableNameToExport] = $value;
                }
            }
        } //(if pgmOutput and it has entries)
        
        return true;
    } //(exportPgmOutputVars)
	
	public function getOutputVarsToExport() {
		return $this->_outputVarsToExport;
	}
    

	// pass in array of job attributes => values to update in the current job.
	// returns true on success, false on failure (failure probably means lack of authority).
	public function changeJob(array $attrs) 
	{
		$cmdString = 'CHGJOB';
		$success = i5_command($cmdString, $attrs);
		return $success;
		
	} //(changeJob)

	/**
	 * given $this->joblog, and an array of program names that might have caused errors,
	 * Extract the error code (CPF or similar) and message text from the joblog.
     * If can't find error in joblog, uses UNEXPECTED 
     *    and text from $this->XMLWrapper->getLastError();
	 *
	 * Code is placed in $this->cpfErr. Text goes to $this->error.
	 * 
	 * @param array $programsToLookFor
	 * @return boolean    True on success, False on failure
	 */
	protected function extractErrorFromJoblog(array $programsToLookFor) 
	{
		            		// CPF, CPC, CPE...
            		// also get between
            		/*Message . . . . :   Invalid length. MAXLEN for data queue NEWQ in CWDEMO is
                                       128.
                                     Cause . . . . . :  */
		
		
		    // where we can find info in joblog
			$cpfOffset = 0; // first 7 chars is CPF
			$cpfLen = 7;
			
			$pgmOffset = 67; // program name found on same line as CPF code, offset 68
			$pgmLen = 10;
						
			$messageLabel = 'Message . . . . :';
			$messageLabelOffset = 37; // "Message . . . . :   "
			$messageLabelLen = strlen($messageLabel); 
			
			$causeLabel = 'Cause . . . . . :';
			$recoveryLabel = 'Recovery  . . . :';

			
			
			// split on line feeds, then put in reverse order so that we'll get the latest first
			$joblogLines = $lines = preg_split( '/\r\n|\r|\n/', $this->joblog); // split on 0D0A etc.

			// in reverse order, look for line with program given/
			// "true" in array_reverse() keeps array index/record numbers intact.
			$startingLine = 0;
			foreach (array_reverse($joblogLines, true) as $lineNum=>$lineString) {

				// Look for program name that we originally called.
				// Trim spaces from the right but not the left. (Need pgm name to START in precise location)
				$substringAtProgramLocation = rtrim(substr($lineString, $pgmOffset, $pgmLen));
  
            	if (in_array($substringAtProgramLocation, $programsToLookFor)) {
            		$startingLine = $lineNum;
            		break;
            		
            	}
            } //(foreach $joblogLines)

            if ($startingLine) {
            	// we found a joblog entry for the program that we called.
            	
            	// first line of section has CPF code as well as program name.
            	$firstLine = $joblogLines[$startingLine];
            	
            	// get the error code. We call it CPF but it could also be GUI, CPE, CPC....
            	$cpfCode = substr($firstLine, $cpfOffset, $cpfLen);

            	// go forward till we hit the end or till we come to a new CPF code (detect that if find a fully 7-position string at start)
            	$msgText = '';
            	$startCollecting = false;
            	// get rid of lines before starting line
            	$joblogLines = array_slice($joblogLines, $startingLine);
            	while (($lineString = next($joblogLines)) && ($lineString !== false) && (strpos($lineString, ' ', $cpfOffset) < $cpfLen)) {
            		
            		// but start collecting text when we find "Message" label.
            		if (substr($lineString, $messageLabelOffset, $messageLabelLen) == $messageLabel) {
            			$startCollecting = true;
            		}  
            		
            		if ($startCollecting) {

            			// If not a heading (omit headings)
/*
 5761SS1 V6R1M0 080215                        Display Job Log                        SBSUSA   11/18/11 15:39:54          Page    2
  Job name . . . . . . . . . . :   QSQSRVR         User  . . . . . . :   QUSER        Number . . . . . . . . . . . :   815166
  Job description  . . . . . . :   QDFTSVR         Library . . . . . :   QGPL
MSGID      TYPE                    SEV  DATE      TIME             FROM PGM     LIBRARY     INST     TO PGM      LIBRARY     INST
*/            			
            			$lineLen = strlen($lineString);

            			// Is a heading if one of the following are found. Use !== false because 0 is a valid "found" result.
            			// Check that line length is > 46 before checking for string in position 46, to avoid warning in log
            			$isHeadingLine = (($lineLen > 46 && (strpos($lineString, 'Display Job Log', 46) !== false)) || 
            			                  strpos($lineString, 'Job name', 2) !== false ||
            			                  strpos($lineString, 'Job description', 2) !== false ||
            			                  strpos($lineString, 'MSGID', 0) !== false);
            			 
            			if (!$isHeadingLine) {
            			
            			    // concatenate whole line. We will remove labels later
            			    $msgText .= ' '. trim($lineString);
            			} //(if not a heading line)
            			
            		} //(if $startCollecting)
            		
            	} //(while more lines)

            	/*  Clean up $msgText.
            	 *  Remove text labels and convert multiple spaces to single space 
            	 *  */
            	$old = array($messageLabel, $causeLabel, $recoveryLabel, '   ', '  ');
            	$new = array('', '', '', ' ', ' ');
            	$cleanMsgText = str_replace($old, $new, $msgText);

            	$this->cpfErr = $cpfCode;
            	$this->error = trim($cleanMsgText);

            } else {
	
            	// could not find it.
                // use error text from XML parser
                $this->cpfErr = 'UNEXPECTED';
			    $this->error = $this->XMLWrapper->getLastError();	

            } //(if $startingLine)
			
	
		return true;
	} //( function extractErrorFromJoblog)
		
	
} //(class ToolkitServiceCw)


/**
 * Class to handle errors in a manner similar to the old toolkit.
 * Singleton class because we only hold on to the last error (one).
  *
 */
class I5Error 
{
	static $instance = null;
	static protected $_i5Error = array();
	
    static function getInstance()
	{
		if(self::$instance == NULL){
			$className = __CLASS__;
			self::$instance=new $className();		
		}
        if (self::$instance) {
        	return self::$instance;
        }
	} //(getInstance)
    
	protected function __construct() {
		// initialize
		$this->setI5Error(0, 0, '', '');
	}
	

	// __toString will make it easy to output an error via echo or print
    public function __toString()
    {
    	$err = $this->getI5Error();
        return "i5Error: num={$err['num']} cat={$err['cat']} msg=\"{$err['msg']}\" desc=\"{$err['desc']}\"";
    } //(__toString)
	
	/**
	 * Set error information for last action.
	 * 
	 * @param int    $errNum    Error number (according to old toolkit). Zero/false if no error
	 * @param int    $errCat    Category of error
	 * @param string $errMsg    Error message (often a CPF code but sometimes just a message)
	 * @param string $errDesc   Longer description of error
	 * @return void    
	 */
	public function setI5Error($errNum, $errCat = I5_CAT_PHP, $errMsg = '', $errDesc = '') {
		
		// the array (eventually returned by i5_error() 
		// likes to have both numeric and alphanumeric keys.
		$i5ErrorArray = array(0=>$errNum,     1=>$errCat,      2=>$errMsg,    3=>$errDesc,
		                      'num'=>$errNum, 'cat'=>$errCat, 'msg'=>$errMsg, 'desc'=>$errDesc);
		
		self::$_i5Error = $i5ErrorArray;
		
	} //(setI5Error)
	
    /**
     * Return i5 error array for most recent action.
     * @return array Error array for most recent action.
     */
    public function getI5Error() {
    	return self::$_i5Error;
    } //(getI5Error)
	
	
} //(class I5Error)


/**
 * Object to manage the old toolkit's style of data structure definitions
 */
class DataDescription 
{
	protected $_description = array();
	protected $_originalObjName = '';
	protected $_objInfoArray = array(); // 'lib', 'obj', 'func'
	protected $_connection;
	protected $_inputValues = array();
	protected $_pgmOutput = array();
    protected $_isReceiverOnly = false;
	protected $_isSingleLevelSimpleValue = false;
    protected $_pcmlStructs = array(); // save structs in here
    
    // TODO create methods to handle then make protected
    public $_miscAttributes = array(); // user-defined
    
	// array of simple types, old to new toolkit, with sprintf-style percent formatting.
	protected $_typeMap = array(I5_TYPE_CHAR    => "%sa",
                               I5_TYPE_PACKED  => "%sp%s",
                               // 4 byte float
                               I5_TYPE_FLOAT   => "4f",
                               // data structure
                               I5_TYPE_STRUCT  => "ds",
                               // int32, 4 bytes
                               I5_TYPE_INT     => "10i0",
                               I5_TYPE_SHORT   => "5i0",
                               I5_TYPE_ZONED   => "%ss%s",
                               // TODO not sure if byte really maps to binary. No one knows what BYTE really does
                               I5_TYPE_BYTE    => "%sb",
                               // hole is exclusive to new toolkit.
                               'hole'          => "%sh",
                               );
                               
    protected $_inoutMap = array(I5_IN    => 'in',
                                 I5_OUT   => 'out',
                                 // INOUT is the same as I5_IN||I5_OUT
                                 I5_INOUT => 'both',
                                 I5_BYVAL    => 'val'
                                );                           
	
                                
	/**
	 * Constructor takes an object name (program, data queue, user space) and array-based data description
	 * and does some conversions.
	 * @param string    $objName        name of program, data queue, etc. lib/pgm(svcfunc) or the like.
	 * @param array    $dataDescription array of parameter definitions
	 * @param I5Error  $errorObj        during validation we may set properties of this object.
	 * @param ServiceToolkit $connection   connection object for toolkit
	 */
	public function __construct($objName, array $dataDescription, ToolkitService $connection) 
	{
		if (is_string($objName)) {
			$this->setOriginalObjName($objName);
	        $objInfo = splitLibObj($objName);
			$this->setObjInfo($objInfo);
		}
		
		$this->_description = $dataDescription;
		
		$this->setConnection($connection);
	    	
	} //(__construct)

	// keep it for safekeeping
	protected function setOriginalObjName($originalObjName = '') {
	    $this->_originalObjName = $originalObjName;	
	} 
	
	protected function getOriginalObjName() {
	    return $this->_originalObjName;	
	} 

	// returns "old toolkit" data description
	public function getOriginalDescription() {
	    return $this->_description;	
	} 
	
	// resets "old toolkit" data description
	// Accepts one parm, an array.
	public function setOriginalDescription($desc) {
	    $this->_description = $desc;	
	}
	
	
	protected function setObjInfo($objInfo) {
		$this->_objInfoArray = $objInfo;
	}
	
	
	public function getObjInfo() {
		return $this->_objInfoArray;
	}

	protected function setPgmOutput($pgmOutput = array()) {
		$this->_pgmOutput = $pgmOutput;
	}
	public function getPgmOutput() {
		return $this->_pgmOutput;
	}
	
	protected function setInputValues($inputValues = array()) {

		$this->_inputValues = $inputValues;
	}

	public function setIsReceiverOnly($isReceiverOnly = false) {
        // turn this on when want to use default input variables because we're only RECEIVING data from a program call.
		$this->_isReceiverOnly = $isReceiverOnly;
	}
	
	public function getIsReceiverOnly() {
		return $this->_isReceiverOnly;
	}

	public function setIsSingleLevelSimpleValue($isSingleLevelSimpleValue = false) {
        // turn this on when want to accept a parameter that's a single-level description array with a single value.
		$this->_isSingleLevelSimpleValue = $isSingleLevelSimpleValue;
	}
	
	public function getIsSingleLevelSimpleValue() {
		return $this->_isSingleLevelSimpleValue;
	}
	
	
	// if null, assume we only want a description, no values.
	public function getInputValues() {
		return $this->_inputValues;
	}
	
	protected function setConnection($conn = null) {
	    $this->_connection = $conn;	
	} 
	
	/**
	 * Return toolkit object that was passed in
	 * @return ServiceToolkit
	 */
	public function getConnection() {
	    return $this->_connection;	
	} 
	
	
	/**
	 * Validate that the array is correct with correct data types, etc.
	 * @return boolean   True if validates successfully, false if any invalid elements.
	 */
	public function validate() {
		// TODO add validation as needed
		$objInfo = $this->getObjInfo();
		
		return true;
	}

	public function splitPcmlProgramPath($path) {
	// given a program path that MAY be qualified by a library and slash,
    // such as /QSYS.LIB/*LIBL.LIB/MYPGM.PGM
    // though it QSYS is the program library, QSYS.LIB will only appear once,
	// split it up and return an array of the form:
	// [lib]=>xxx, [obj]=>yyy
	// If no library, that part will be blank.
	
	// Note, library could also be *LIBL.LIB
	 
    // Break up path, separated now by slashes. can be varied lib and pgm.
    // remove the /qsys.lib that may be in front but only if it's simply qualifying another library. qsys may be the actual program library, too.
		
		// trim not only spaces, but slashes, from beginning and end.
		// also make uppercase for consistency. (OK to use uppercase--lib and program here, not function)
		$path = strtoupper(trim($path, " /"));
		
	    // remove .LIB, .PGM, .SRVPGM that might be extensions for IFS-style file path.
	    $path = str_replace(array('.PGM', '.SRVPGM','.LIB'), array('', '', ''), $path);

	    if(!$path) { 
			throw new Exception("PCML program path is required.");
		}

		$result = array('lib'=>'', 'obj'=>'');
		$parts = explode('/', $path);
		$numParts = count($parts);
		
		if($numParts > 3) { 
			throw new Exception("PCML program path should not have more than 3 slash-delimited parts.");
		}
		
		switch ($numParts) {
			case 3: 
			    // 3 parts. QSYS, library, and program was provided.
			    $result['lib'] = $parts[1];
			    $result['obj'] = $parts[2];
			    break;
				
			case 2: 
			    // 2 parts. library, and program were provided.
			    $result['lib'] = $parts[0];
			    $result['obj'] = $parts[1];
			    break;
			    
			case 1: 
			    // 1 part. program was provided.
			    $result['pgm'] = $parts[0];
			    break;

			default:
			    throw new Exception("PCML program path has invalid number of parts (<1 or >3).");
				break;
				
		} //(switch)
		
		return $result;
    } //(splitPcmlProgramPath)
	
	
	/**
	 * Given an array key name, recursively search the input values array
	 * and return the value associated with the key name provided.
	 * @param string $searchKey   key to search for
	 * @return string|array|null  value found in input array for array key. null if failed 
	 */
	protected function findValueInArray($searchKey, $valueArray) {
		$connection = $this->getConnection();

        // ensure that array is not empty
		if (!count($valueArray)) {
		     i5ErrorActivity(I5_ERR_PHP_TYPEPARAM, I5_CAT_PHP, "Array of input values must not be empty", "Array of input values must not be empty");
		     return null;
		} 
		
		
        foreach ($valueArray as $key=>$value) {

	         // a match was found!
		     if ($key == $searchKey) {
//                $valToLog = (is_array($value)) ? print_r($value, true) : $value; 		     	
//		     	$connection->logThis("findValueInArray: searchKey: $searchKey. value found: $valToLog");
		         return $value;
		     }
	    } //(foreach values)

	    // if failed, return null
//	    $connection->logThis("findValueInArray: searchKey: $searchKey. no value found");
	    return null;
	} //(findValueInArray)
	
	
/*	 
 *   Process a single parameter definition, converting from old toolkit to new toolkit style.
 * 
 *   * Each description item contains: 
	 * Name - name of the field
Type - type of the field, can be one of Data types
Length
    for CHAR, BYTE - integer describing length. Length can be number or name of the variable holding the length in the data
structure.
    for PACKED, ZONED - string "NUMBER.NUMBER" defining length and precision
    for STRUCT - array containing data definition of the structure
        Data structure is defined via PHP as follows:
        DSName - name of the parameter
        DSParm (optional) - array of the parameter of the Data structure. Each parameter is defined by a data definition in the same
               format as described here.
    for INT, FLOAT - ignored
IO - can be one of I/O values (I5_IN|I5_OUT, I5_INOUT). Default is I5_IN
count (optional) - repetition count if the field is an array
countRef (optional) - reference to the repetition count if the field is an array

return: array of new or, if a problem, false.

*/	
    protected function oldToNewDescriptionItem($oldDataDescription = array(), $inputValues = null) {
		// pass in old, return new
		
		if (!$oldDataDescription || !is_array($oldDataDescription) || !count($oldDataDescription)) {
			return false;
		}

		// if building a "receive-only" data structure, we can use default values.
		$useDefaultValues = $this->getIsReceiverOnly();

		// convert keys to lowercase to make case-insensitive
		// because key case is usually inconsistent with toolkit
	    // PHP function array_change_key_case() works on top level of array.
		$old = array_change_key_case($oldDataDescription, CASE_LOWER);
        
		// can initialize with saved array if not planning to use default values anyway
		if (!$inputValues && !$useDefaultValues) {
		    $inputValues = $this->getInputValues();
		}
		
		$connection = $this->getConnection();
//		$connection->logThis("desc in: " . print_r($old, true) . " value array in: " . print_r($inputValues, true));

//		$connection->logThis("use default values? $useDefaultValues");
				
		// get count/dim (0 if none)
	    $dim = 0; // default
	    if (isset($old['count']) && $old['count']) {
	        $dim = $old['count'];        	
	    } elseif (isset($old['countref']) && $old['countref']) {
	        // countref takes value from a param value
	        // Find the input array entry that countref references, and assign its value to $dim.
	    	$nameContainingCount = trim($old['countref']);
	    	if ($useDefaultValues) {
	    		$countRefValue = 999; // for argument's sake. We don't have a countref value to refer to.
	    	} else {
	    		// get value of actual field referred to by countref.
	    	    $countRefValue = $this->findValueInArray($nameContainingCount, $inputValues);
	    	}
            // if key found, value must be numeric (numeric string or integer) because it'll be our count.
		    if (is_numeric($countRefValue)) {
			    $dim = trim($countRefValue);
		    } else {
		        // error! not found, or an array or possibly a non-numeric string.
		        i5ErrorActivity(I5_ERR_PHP_TYPEPARAM, I5_CAT_PHP, "Value for CountRef, field $nameContainingCount, must exist and be numeric", "Value for CountRef, field $nameContainingCount, must exist and be numeric"); 
		        return false;
		    }
	    } //(if count/refcount)
	            
        // input or output. default to input. 
        // May have multiple values OR'ed together.
        $io = (isset($old['io']) && $old['io']) ? $old['io'] : I5_IN;
	    // get new IO from old. Try one at a time.
	    $inOutStuff = $io & I5_INOUT; // two bits. could be IN, OUT, or INOUT
	    $byVal = $io & I5_BYVAL;
        
	    $newInout = (isset($this->_inoutMap[$inOutStuff])) ? $this->_inoutMap[$inOutStuff] : 'in';
        $newBy = (isset($this->_inoutMap[$byVal])) ? $this->_inoutMap[$byVal] : ''; // default is blank

		// get name
	    $name = (isset($old['name']) && $old['name']) ? $old['name'] : '';
		
	    // get dsname (only present if a data structure)
	    $dsName = (isset($old['dsname']) && $old['dsname']) ? $old['dsname'] : '';
		
        if ($dsName) {
            // data structure detected!
            
            // See if there is a DSParm containing subfields.
            $dsParm = (isset($old['dsparm']) && $old['dsparm']) ? $old['dsparm'] : '';
                        
            // check that it's an array, which dsParm should be
            if (!is_array($dsParm)){
    	       i5ErrorActivity(I5_ERR_PHP_TYPEPARAM, I5_CAT_PHP, 'DSParm must be an array', 'DSParm must be an array');
	           return false;
            }
            // check that it's non-empty
            if (!count($dsParm)) {
    	       i5ErrorActivity(I5_ERR_PHP_TYPEPARAM, I5_CAT_PHP, 'DSParm must not be empty', 'DSParm must not be empty');
	           return false;
            }
            
	        // get array of subfield input values for this data structure
            if ($useDefaultValues) {
            	// create values to fill array hinted at by dsParm.
               $dsData = array();
               
               foreach ($dsParm as $subParm) {
                   $subParm = array_change_key_case($subParm, CASE_LOWER); // for consistency    	
                   // look for name or dsname
                   $subname = '';
                   if (isset($subParm['name'])) {
                       $subname = $subParm['name'];
                   } elseif(isset($subParm['dsname'])) {
                   	   $subname = $subParm['dsname'];	
                   }
                   if (!$subname) {
        		       i5ErrorActivity(I5_ERR_PARAMNOTFOUND, I5_CAT_PHP, "Subfield of $dsName does not have a name itself", "Subfield of $dsName does not have a name itself");
                       return false;
                   }
                   $dsData[$subname] = ''; // default value. TODO Could do 0 or something for numeric        
               } //(foreach)
            	
               
            } else {
                // use real values from input array 
	            $dsData = $this->findValueInArray($dsName, $inputValues);

            	if (!$dsData) { 
    			    // ds has no description to match value!
        		    i5ErrorActivity(I5_ERR_PARAMNOTFOUND, I5_CAT_PHP, "Requested parameter $name does not exist in the description", "Requested parameter $name does not exist in the description");
                    return false;
	            }
            } //(if useDefaultValues / else)
	        
	       if ($dim > 1) {
	       	
	           // if we use default values, employ the "dim" attribute to handle dim/array of DS.
	           // if we use real values, expect an array of arrays to exist, and dsData is the outer array to be looped through.	
	       	
	       	   if ($useDefaultValues) {
	       	       // make an array out of dsData's dummy values, repeating $dim times. Below there's a loop through it..
	       	       $dsData = array_fill(0, $dim, $dsData);
	       	   }	
	       	   
            	// array of identical DS'es.
            	// TODO check that count of ds values (each a ds) does not exceed dim.

	            /*	$connection->logThis("array of DS found. dsName: $dsName. dsData: " . print_r($dsData, true) . ' dsParm: ' . print_r($dsParm, true));
	        	*/
	       	
	        	// treat each ds and data array separately.
	        	// loop through input values array for DS
	        	$dsDataValues = array();
	        	foreach ($dsData as $numericIndex=>$dsDataSingle) {
	        		// work with a single data structure
	        		// *** dsParm (structure) will be the same for each ds in the array ****
	        		// recursively handle each ds in array and add to dsDataValue array.
	        		
	        		// Handle one data array element at a time
	        		
	        		// We will have something like:
	        		// dsparm: 
/*	        		array (
                           array ("Name"=>"PS1", "IO"=>I5_INOUT, "Type"=>I5_TYPE_CHAR, "Length"=>10),
                           array ("Name"=>"PS2", "IO"=>I5_INOUT, "Type"=>I5_TYPE_CHAR, "Length"=>10),
                           array ("Name"=>"PS3", "IO"=>I5_INOUT, "Type"=>I5_TYPE_CHAR, "Length"=>10)
                           );
*/	        		
	        		// dsdata:
/*	        		array(
                          array("PS1"=>"test1", "PS2"=>"test2", "PS3"=>"test3"),
                          array("PS1"=>"test3", "PS2"=>"test4", "PS3"=>"test5")
                          );
*/	        		
	        		
//	        		$connection->logThis("recursively handle a single DS from an array");
	        		// pass in full description of DS, including DS name etc., but with count = 1.
	        		$singleDsDesc = $old;
	        		unset($singleDsDesc['count'],$singleDsDesc['countref']); // single now
	        		//$tempDsName = "{$dsName}_{}"; 
	        		// use numeric index (0, 1, 2, 3...) as "name" of array elements
	        		$tempDsName = "{$dsName}_{$numericIndex}";
	        		$singleDsDesc['dsname'] = $tempDsName;
	        		// pass in the ds elements and the input data for it 
	        		$dsDataValues[] =  $this->oldToNewDescriptionItem($singleDsDesc,array($tempDsName=>$dsDataSingle));
	        	} //(foreach dsdata)
	            
	        	// create a ds to house the array of DSes. 
//	        	$connection->logThis("about to create arrayed ds called $dsName with: " . print_r($dsDataValues, true));
	        	$new = new DataStructure($dsDataValues, $dsName, 0, false, '', true); // 'true' says this is an array
	       	   //} //(default / real values)
	       	   
            } else {
	            // not an array of DSes. A single DS.
	        
		        foreach ($dsParm as $singleParm) {
		        	// singleParm is something like this:
	/*	        	   [Name] => PS1
                       [IO] => 3
                       [Type] => 0
                       [Length] => 10*/

//	       	    	$connection->logThis("dsName: $dsName. singleparm: " . print_r($singleParm, true));
	       	    	// do it within ds
	               // Try some recursion to get each subfield.
	       	    	
	       	    	$dataValue[] = $this->oldToNewDescriptionItem($singleParm, $dsData);	
	       	    }
                 
//	       	    $connection->logThis("about to add to data structure this array: " . print_r($dataValue, true));
	            // create a ds based on individual parms gathered above.
       	        $new = new DataStructure($dataValue, $dsName);
//       	        $loggableNew = (array) $new;
		                          
            //$connection->logThis("just said new data structure: " . print_r($loggableNew, true));
       	        
            } //(dim ds or regular ds)
                
        }  else {
        
            // *** not a data structure. A regular element (could be an array or single value). ***
		
		    // data type. don't check for "empty" or $old[['type'], because 0 is legit (CHAR).
		    $type = (isset($old['type'])) ? $old['type'] : '0';
		    // get new type from old
	        $newType = ($this->_typeMap[$type]) ? $this->_typeMap[$type] : ''; 
	
	        // get length if there is one	
		    $length = (isset($old['length']) && $old['length']) ? $old['length'] : '';
	        // split into whole and decimal parts. may be like "3" or "3.1"
		    list($whole, $dec) = explode('.', $length) + array('', ''); // extra array avoids Undefined index errors
		
            if ($useDefaultValues) {
            	// if $dim, it's an array. Otherwise a single value.
            	if ($dim > 1) {
            		// array of dummy values, dimention of $dim
            		$dataValue = array_fill(0, $dim, '');
            		$isArray = true;
            	} else {
            		// single dummy value
            		$dataValue = '';
            		$isArray = false; 	
            		// and leave $dim alone to flow into the ProgramParmeter below.
            	} //(dim > 1)
            	
            } else {
            	// real values
			    $dataValue = $this->findValueInArray($name, $inputValues);
	            // make sure array count doesn't exceed $dim (planned count).
	            $isArray = is_array($dataValue);
	            if ($isArray) {
	            	if (count($dataValue) > $dim) {
	            		i5ErrorActivity(I5_ERR_ENDOFOCC, I5_CAT_PHP, "Number of array elements in $name greater than the maximum, $dim, set in the description", "Number of array elements in $name greater than the maximum, $dim, set in the description");
		                return false;
	            	}
	            } 
	            

            } //(default values / real values)
            
	        // done with $dim. PHP wrapper handles dim differently.
            $dim = 0;
            	            
            //$type,  $io, $comment='', $varName = '', $value, $varing = 'off', $dimension = 0, $by = 'ref')
	        $new = new ProgramParameter(
                                        // type
	 	                            sprintf($newType, $whole, $dec),
		                            // io
		                            $newInout,
		                            // comment 
		                            $name,
		                            // varName
		                            $name,
		                            // value
		                            $dataValue,
		                            // varing   
		                            'off',
		                            // dimension
		                            $dim,
		                            // by (val or ref)
		                            $newBy,
		                            // is array says the param is an array
		                            $isArray
		                           );
		    $loggableValue = (is_array($dataValue)) ? print_r($dataValue, true) : $dataValue;                      
//            $connection->logThis("just said new ProgramParameter with name: $name and dataValue: $loggableValue");
		
	} //(dsparm or not)
	
	return $new;
	
    } //(end of function)
	
		
	/**
	 * Take the previously given data description and match up with values and output params
	 * to make a parameter array/object that can be presented to a program or data queue, etc.
	 * If any error or validation problem occurs (such as a value not matching data type), return false.
	 * 
	 * 
	 * @param array $input                 Data input params
	 * @param array $description[optional] Description of data, if want to specify explicitly 
	 *                                     rather than to use description from class member.  
	 * @return array|boolean Return the param array or, if an error occurs, false.
	 */
	public function generateNewToolkitParams($input = array(), $description = null) {
        $paramsForNewToolkit = array();

        // store input value array for safekeeping.
        // could be blank.
        $this->setInputValues($input);
        
        // use specified description if available, otherwise class member description.
        $description = ($description) ? ($description) : $this->_description;
         

        // do one at a time
        foreach ($description as $key=>$descParam) {

        	// convert top-level keys to lower case for consistency.
            $descParam = array_change_key_case($descParam, CASE_LOWER);

        	// if an input value wasn't specified for a param definition/description,
            // set a flag to provide default input values, as a placeholder.
        	
        	$needDefaultInput = false; // default 
        	
        	// if not globally specified as needing default input values
        	if (!$this->getIsReceiverOnly()) {
        	
	        	// desc name can be given under the index "name" or "dsname".
	        	if ((isset($descParam['name']) && $descParam['name'])) {
	        		$name = $descParam['name'];
	        	} elseif (isset($descParam['dsname']) && $descParam['dsname']) {
	                $name = $descParam['dsname'];                   		
	        	} else {
	        	    i5ErrorActivity(I5_ERR_PHP_TYPEPARAM, I5_CAT_PHP, "Parameter name in description is missing or blank",  "Parameter name in description is missing or blank");
	        	    return false;
	        	} //(if name or dsname given)
	        	
	        	// if corresponding input param not given, set flag for using default.
	        	$needDefaultInput = !isset($input[$name]);
	        		
        	} //(if not receive only)

        	if ($needDefaultInput) {
        		// only set this if didn't already turn on receiver-only globally. We don't want to interfere then.
        		$this->setIsReceiverOnly(true);
        	} 
        	
        	// convert param from old toolkit style to new.
            $paramsForNewToolkit[] = $this->oldToNewDescriptionItem($descParam);
            
            if ($needDefaultInput) {
        		// revert back to false.
        		$this->setIsReceiverOnly(false);
        	} 
            
	
        } //(foreach)
        
	    
        // update with values
        // TODO: when count/dim is specified, use it as max array size. otherwise error 38 should occur.
        //ProgramParameter::UpdateParameterValues($paramsForNewToolkit, $input);
        
        return $paramsForNewToolkit;
		
	} //(generateNewToolkitParams)

	
	// TODO perhaps callProgram should stand on its own in the regular CW class.
    //      It's not really part of the data description.

	
	/**
	 * Given input values and an output array in a particular format, 
	 * and having captured the data description and program info
	 * in the constructor, and having converted the data desc and interpolated the values,
	 * Now we call the program and return an array of output variables.
	 * 
	 * @param array $newInputParams   New-style toolkit array of params including values
	 *                                (use generateNewToolkitParams($inputValues) to create it) 
	 * @return boolean             true if OK, false if it didn't succeed.
	 */
	public function callProgram($newInputParams = array())
	{
		
		$pgmInfo = $this->getObjInfo();
		$pgmName = $pgmInfo['obj'];
		$lib =     $pgmInfo['lib'];
        $func =    $pgmInfo['func'];
        $options = array();
        // if a service program subprocedure (function) is defined
        if ($func) {
        	$options['func'] = $func;
        }		
		$pgmCallOutput = $this->getConnection()->PgmCall($pgmName,
		                                         $lib,
	                                             $newInputParams,
	                                             // null for returnvalue var because old toolkit doesn't handle return values (as far as we can tell)
							                     null, 
							                     $options);

		// TODO handle errors
		$conn = $this->getConnection();
		if ($pgmCallOutput) {
            $outputParams = $conn->getOutputParam($pgmCallOutput);
		    $this->setPgmOutput($outputParams);
		    return true;
        } else {
        	return false;
        }
		
	} //(function callProgram)
	
	// proxies to full function.
	public function getOutput() {
		return $this->getConnection()->getOutputVarsToExport();
	}
	
	
} //(Class DataDescription)


/* 
 * Additional functionality for parsing PCML
 */
class DataDescriptionPcml extends DataDescription
{
	/**
	 * Constructor takes a PCML string and converts to an array-based old toolkit data description string.
	 * @param string    $pcml              The string of PCML
	 * @param ServiceToolkit $connection   connection object for toolkit
	 */
	public function __construct($pcml, ToolkitService $connection) 
	{
		
		$this->setConnection($connection);

		// Convert PCML from ANSI format (which old toolkit required) to UTF-8 (which SimpleXML requires).
		// No harm if the string is already in UTF-8.
		$pcml = utf8_encode($pcml);
		
        //program name is stored as: /pcml/program name="/qsys.lib/eacdemo.lib/teststruc.pgm"
        $xmlObj = new SimpleXMLElement($pcml);

        // get root node and make sure it's named 'pcml'
        if(!isset($xmlObj[0]) || ($xmlObj[0]->getName() != 'pcml')) {
        	throw new Exception("PCML file must contain pcml tag");
        }

        $pcmlObj = $xmlObj[0];
        
        // get program name, path, etc.
        if(!isset($pcmlObj->program) || (!$pcmlObj->program)) {
        	throw new Exception("PCML file must contain program tag");
        }
        $programNode = $pcmlObj->program;
        
        $pgmAttrs = $programNode->attributes();

       
        /*sample:
<program name="name"
[ entrypoint="entry-point-name" ]
[ epccsid="ccsid" ]
[ path="path-name" ]
[ parseorder="name-list" ]
[ returnvalue="{ void | integer }" ]
[ threadsafe="{ true | false }" ]>
</program>*/

        // let's focus on name, path, and entrypoint, the only attributes likely to be used here.
        $givenPgmName = (isset($pgmAttrs['name'])) ? $pgmAttrs['name'] : '';
        $path = (isset($pgmAttrs['path'])) ? $pgmAttrs['path'] : '';
        $entrypoint = (isset($pgmAttrs['entrypoint'])) ? $pgmAttrs['entrypoint'] : '';
        
        // Note: if entrypoint is supplied, it's the function in a service program. "name" will be the same as entrypoint.
        // if entrypoint is not supplied, name is the actual program name.
        // Therefore, "name" seems somewhat worthless.
        
        // break up path, separated now by slashes. can be varied lib and pgm.
        // remove the /qsys.lib that may be in front but only if it's simply qualifying another library. qsys may be the actual program library, too.
        
        $objArray = $this->splitPcmlProgramPath($path);        
        if ($objArray['lib']) {
        	$pgmName = "{$objArray['lib']}/{$objArray['obj']}"; 
        } else {
        	$pgmName = $objArray['obj'];
        }

        // now add the entrypoint, if any, as a procedure/function.
        if ($entrypoint) {
            // append the entry point enclosed in parentheses.
        	$pgmName .= "($entrypoint)";
        }

        // Now create data description array.
        $dataDescriptionArray = $this->pcmlToArray($xmlObj);

		// call parent's constructor with:
		//$descObj = new DataDescriptionPcml($description, $connection);
        parent::__construct($pgmName, $dataDescriptionArray, $connection);		
	} //(__construct)

	
	// array of simple types, PCML to old toolkit
	protected $_pcmlTypeMap = array('char'          => I5_TYPE_CHAR,
                                'packed'        => I5_TYPE_PACKED,
                               // 4 byte float
                                'float'         => I5_TYPE_FLOAT,
                               // data structure
                                'struct'        => I5_TYPE_STRUCT,
                               // int32, 4 bytes
                                'int'           => I5_TYPE_INT,
                                'zoned'         => I5_TYPE_ZONED,
                               // TODO not sure if byte really maps to binary. No one knows what BYTE really does
                                'byte'          => I5_TYPE_BYTE,
                               );
                               
    // PCML usage mapping                               
    protected $_pcmlInoutMap = array('input'         => I5_IN,
                                     'output'        => I5_OUT,
                                     'inputoutput'   => I5_INOUT,
                                     // inherit means inherit from parent element, and if no parent element, do INOUT.
                                     // TODO implement "inherit" more precisely, checking parent element's usage.
                                     'inherit'       => I5_INOUT,
                                );                           
	
	
    // maintain an array of pcml structures                                
    protected $_pcmlStructs = array();                                

	// given a single ->data or ->struct element, return an array containing its contents as old toolkit-style data description.
	public function singlePcmlToArray(SimpleXmlElement $dataElement) 
	{
		
		$tagName = $dataElement->getName();
		
		// get attributes of this element.
		$attrs = $dataElement->attributes();
		
		// both struct and data have name, count (optional), usage
		$name = (isset($attrs['name'])) ? (string) $attrs['name'] : '';
		$count = (isset($attrs['count'])) ? (string) $attrs['count'] : '';
		$usage = (isset($attrs['usage'])) ? (string) $attrs['usage'] : '';
		$structName = (isset($attrs['struct'])) ? (string) $attrs['struct'] : '';	

		// fill this if we have a struct
		$subElements = array();
		
		
		// should all be data 
		if ($tagName == 'data') {
			
			$type = (isset($attrs['type'])) ? (string) $attrs['type'] : '';
			
			// if a struct then we need to recurse.
			if ($type != 'struct') {
				
				// regular type (char, int...), not a struct, so the data element's name is just 'name'.
				$nameName = 'Name';
				
			} else {
				
				// it IS a struct.
				
				// old toolkit uses DSName for a data structure's name.
				$nameName = 'DSName';
				
				$theStruct = null; // init
				
				// look for matching struct
				if ($this->_pcmlStructs) {
					
					// TODO verify type with is_array and count 
					foreach ($this->_pcmlStructs as $possibleStruct) {
						$possStructAttrs = $possibleStruct->attributes();
						if ($possStructAttrs['name'] == $structName) {
							$theStruct = $possibleStruct;
							$structAttrs = $possStructAttrs;
							break;
						}
					}
				} //(if array of structs exists)				

				// if struct was not found, generate error for log
				if (!$theStruct) {
//				    $this->getConnection->logThis("PCML structure '$structName' not found.");
				    return null;
				}
				
                // if we got here, we found our struct.
				
				// count can also be defined at the structure level. If so, it will override count from data level)
				if (isset($structAttrs['count'])) {
					$count = (string) $structAttrs['count'];
				} //(if count supplied at structure level)

				// "usage" (in/out/inherit) can be defined here, at the structure level.	
				$structUsage = (isset($structAttrs['usage'])) ? (string) $structAttrs['usage'] : '';

				// if we're not inheriting from our parent data element, but there is a struct usage, use the struct's usage (input, output, or inputoutput).
				if (!empty($structUsage) && ($structUsage != 'inherit')) {
					$usage = $structUsage; 
				}
				
				$structSubDataElementsXmlObj = $theStruct->xpath('data');
				if ($structSubDataElementsXmlObj) {
					foreach ($structSubDataElementsXmlObj as $subDataElementXmlObj) {
						
						if ($subDataElementXmlObj->attributes()->usage == 'inherit') {
							// subdata is inheriting type from us. Give it to them.
							$subDataElementXmlObj->attributes()->usage = $usage; 
						}
						
						// here's where the recursion comes in. Convert data and add to array for our struct.
						$subElements[] = $this->singlePcmlToArray($subDataElementXmlObj);
						  
					}
					
				} //(if data elements under this struct xml obj were found)	
			
			} //(if type of data is struct)
			
			
			$length = (isset($attrs['length'])) ? (string) $attrs['length'] : '';
			$precision = (isset($attrs['precision'])) ? (string) $attrs['precision'] : '';
			
			//$struct = (isset($attrs['struct'])) ? (string) $attrs['struct'] : ''; // if this is pointing to a struct name
			
			$newType = (isset($this->_pcmlTypeMap[$type])) ? (string) $this->_pcmlTypeMap[$type] : ''; 
			
			$newInout = (isset($this->_pcmlInoutMap[$usage])) ? (string) $this->_pcmlInoutMap[$usage] : ''; 
			
			
			// create new length using precision if necessary
			if ($precision) {
				$newLength = "$length.$precision"; 
			} else {
				$newLength = $length;
			} //(if precision)
			
		} //(tagName == 'data')
		
		// count
		$newCount = 0; // initialize
		$newCountRef = '';
		if (is_numeric($count) && ($count > 0)) {
			$newCount = $count;
		} elseif (is_string($count) && !empty($count)) {
			// count is character, so it's really a countref
			$newCountRef = $count;
		} //(count)

		$element = array();
		
		$element[$nameName] = $name;

		// if not a struct, provide data type.
		if ($type != 'struct') {
			$element['Type'] = $newType;
		}
		
		if ($newCount) {
		    $element['Count'] = $newCount;	
		}
		if ($newCountRef) {
		    $element['CountRef'] = $newCountRef;	
		}
		if ($newLength) {
		    $element['Length'] = $newLength;	
		}
		if ($newInout) {
		    $element['IO'] = $newInout;	
		}
		
		if (count($subElements)) {
			$element['DSParm'] = $subElements;
		}
		
		return $element;
		
	} //(singlePcmlToArray)
	
	// given an XML object containing a PCML program definition, return an old toolkit style of data description array. 
	public function pcmlToArray(SimpleXMLElement $xmlObj) {
	    
		$dataDescription = array();
		
		// put structs in its own variable that can be accessed independently.
		$this->_pcmlStructs = $xmlObj->xpath('struct');
		
		// looking for ->data and ->struct.
        $dataElements = $xmlObj->xpath('program/data');

        if ($dataElements) {
        	foreach ($dataElements as $dataElement) {
        		
                $dataDescription[] = $this->singlePcmlToArray($dataElement);		
        	}
        } //(if dataElements)
		
		return $dataDescription;
		
	} //(pcmlToArray)

	
} //(PCML parsing class)


    
