<?php
namespace ToolkitApi;

include_once 'ToolkitServiceSet.php';

use ToolkitApi\XMLWrapper;
use ToolkitApi\ProgramParameter;
use ToolkitApi\httpsupp;
use ToolkitApi\db2supp;
use ToolkitApi\odbcsupp;

use ToolkitApi\CharParam; // part of ToolkitServiceParameter.php
use ToolkitApi\Int32Param; // part of ToolkitServiceParameter.php
use ToolkitApi\SizeParam; // part of ToolkitServiceParameter.php
use ToolkitApi\SizePackParam; // part of ToolkitServiceParameter.php
use ToolkitApi\Int64Param; // part of ToolkitServiceParameter.php
use ToolkitApi\UInt32Param; // part of ToolkitServiceParameter.php
use ToolkitApi\UInt64Param; // part of ToolkitServiceParameter.php
use ToolkitApi\FloatParam; // part of ToolkitServiceParameter.php
use ToolkitApi\RealParam; // part of ToolkitServiceParameter.php
use ToolkitApi\PackedDecParam; // part of ToolkitServiceParameter.php
use ToolkitApi\ZonedParam; // part of ToolkitServiceParameter.php
use ToolkitApi\HoleParam; // part of ToolkitServiceParameter.php
use ToolkitApi\BinParam; // part of ToolkitServiceParameter.php
use ToolkitApi\DataStructure; // part of ToolkitServiceParameter.php

define('CONFIG_FILE', 'toolkit.ini');

class ToolkitService {
	
	const VERSION =  "1.6.0"; // version number for front-end PHP toolkit
	
	/* TODO use inputXml and outputXml to make this class more flexibly OO-like. Fewer strings copied around.
	 * Better would be to use a Request object that has a connection. 
	 * There could be multiple Request objects even if only one connection. 
	 * Each request object could have its own input and output.
	*/
	protected $XMLWrapper = null;
	protected $conn = NULL;	// connection to database or other transport
	
	// TODO create methods to set (separately and all at once) and get errors, akin to what was done for DB module.
	// Test ability to retrieve program errors and text.
	protected $error = ''; // ambiguous usage (it's here for backward compat.) but mainly 7-char error code 
	protected $cpfErr = ''; // 7-char error code
	protected $errorText = ''; // error text/msg

	// $db2 variable may not be needed. Consider deprecating in future.
	protected $db2 = false;
	protected $db = null; // contains class for db connections

	protected $_i5NamingFlag = 0; // same as DB2_I5_NAMING_OFF; // Other value could be 1 (DB2_I5_NAMING_ON). 
	protected $_schemaSep = '.'; // schema separator. A dot or slash
    protected $_validSeparators = array('.', '/');

	protected $_outputVarsToExport = array();
	protected $_isPersistent = false;
	
	protected $_isCw = false; // whether the CW is used for this instance.
	
	static protected $_config; // config options from INI file. Accessed by static method getConfigValue(); 
    static protected $_os; // operating system
	
	// brought over from CW
	protected $joblog = '';
	protected $_privateConnNum = null;
	protected $_isNewConn = true; // default to "new/true" because it's safest. new means app perhaps should initalize job.
	// In case of error, look for CPFs generated by specific other programs.
	// E.g. if userid is wrong when calling QSYGETPH, the CPF may be reported by program QSYPHDL in joblog.
	// TODO would be better specified in external file or in INI.
	protected $_cpfMapping = array('QSYRUSRI' => array('QLIROHDL'),
			'QSYGETPH' => array('QSYPHDL'));
	
	
    // options that can be set at any time
    // Set them with setOptions or setToolkitServiceParams
    // Get them with getOption or getToolkitServiceParam	
    protected $_options = array('plug'           => 'iPLUG512K', //for ibm_db2. for  odbc $plug='iPLUGR512K'.  consider 4K with small data
					            'plugSize'       => '512K',  // 4K, 32K, 512K, 65K, 512K, 1M, 5M, 10M, 15M
					            'plugPrefix'     => 'iPLUG', // iPLUG (ibm_db2) or iPLUGR (odbc)
								'XMLServiceLib'  => XMLSERVICELIB, // library containing XMLSERVICE
								'HelperLib'      => ZSTOOLKITLIB,  // library containing Zend Server's RPG service program (ZSXMLSRV by default) that handles some of the toolkit's duties.
								'v5r4'           => false, // whether to ask XMLSERVICE to carefully use features that v5r4 can handle
								'sbmjobParams'   => '', // XMLSERVICE itself will provide good defaults in most cases (in production ZENDSVR(6)/ZSVR_JOBD/XTOOLKIT. In test mode, QSYS/QSRVJOB/XTOOLKIT). See PLUGCONF1 and 2
								'debug'          => false,
								'debugLogFile'   => '/usr/local/zendsvr6/var/log/debug.log',
    		                 // CCSID/Hex at a global/request level. These properties are also defined at a parameter object level.
								'ccsidBefore'    => '',     
								'ccsidAfter'     => '',
								'useHex'         => false,
								'paseCcsid'      => '', // PASE CCSID for <sh> pase such as WRKACTJOB
								'trace'          => false, // whether to enable XMLSERVICE internal log
								'sbmjobCommand'  => '', // optional complete override of SBMJOB command when new toolkit job is submitted
								'prestart'       => false,
								'stateless'      => false,
								'performance'    => false, // whether to enable performance collection (not fully implemented)
								'idleTimeout'    => '',  // created for Compat. Wrapper (CW)
								'cdata'          => true, // whether to ask XMLSERVICE to wrap its output in CDATA to protect reserved XML characters
								'internalKey'    => XMLINTERNALKEY, // consistent naming style
								'encoding'       => "ISO-8859-1", /*English. Hebrew:ISO-8859-8 */
								'schemaSep'      => '.', // schema separator. A dot or slash
								'parseOnly'      => false, // do not run any program; simply parse, expand dim if necessary, and return.
								'parseDebugLevel' 
										         => 1,  // 1-9 debug level when in parseOnly mode
								'license'        => false, // true to receive license/version information
								'transport'      => false, // check proc call speed (no XML calls)
								'dataStructureIntegrity'    
								                 => false, // New in 1.4.0. Specify true to preserve integrity of data structures. If false (default), explode inner values out of the ds.
								'arrayIntegrity' => false, // New in 1.4.0. Specify true to preserve integrity of arrays (to create true named arrays, not merely sequentially numbered elements). 
								'customControl'  => '', // any string you want. Will be concatenated to control key string after a single space.
								'transportType'  => 'ibm_db2', // can override in getInstance constructor as well
								'httpTransportUrl'
								                 => '', // for HTTP REST transport 
								'timeReport'      => false, // *fly or *nofly; if true, return tick counts instead of data.            
    );

    // plug size to bytes cross-reference
    protected $_dataSize = array("4K"   => 4096, 
	                             "32K"  => 32000,
	                             "65K"  => 65000,
	                             "512K" => 512000,
	                             "1M"   => 1000000,
	                             "5M"   => 5000000,
	                             "10M"  => 10000000,
	                             "15M"  => 15000000,
    );
    
	static protected $instance = NULL;

    // need to define this so we get Cw object and not parent object
    static function getInstance($databaseNameOrResource = '*LOCAL', $userOrI5NamingFlag = '', $password = '', $transportType = '', $isPersistent = false)
	{
	    // if instance hasn't been created yet, create one
		if(self::$instance == NULL){
			$toolkitService = __CLASS__;
			self::$instance=new $toolkitService($databaseNameOrResource, $userOrI5NamingFlag, $password, $transportType, $isPersistent);
		}
		
        if (self::$instance) {
        	// we have an instance
        	return self::$instance;
        } else {
        	// some problem
    // only if CW    	setError(I5_ERR_NOTCONNECTED, I5_CAT_PHP, 'Cannot get a connection', 'Cannot get a connection');
        	return false;
        } //(if (parent::$instance))
	} //(getInstance)

	
	public function __destruct(){
		
		// if no transport then remove toolkit instance as well.
		if(!isset($this->conn) || $this->conn == null)
			self::$instance = NULL;

	} //(public function __destruct(){


	/**
	 * Return true if an instance of this object has already been created.
	 * Return false if no instance has been instantiated.
	 *
	 * Useful when users need to know if a "toolkit connection" has already been made.
	 * Usage:
	 * $isConnected = ToolkitService::hasInstance();
	 *
	 * @return boolean
	 */
	static function hasInstance() {

		if (isset(self::$instance) && is_object(self::$instance)) {
		    return true;
		} else {
			return false;
		}
	} //(hasInstance())

	/**
	 * Return true if we are in debug mode
	 * Return false if not
	 *
	 * Usage:
	 * $isDebug= $this->isDebug();
	 *
	 * @return boolean
	 */
    protected function isDebug() 
    {
	    return $this->getOption('debug');
	
    } //(isDebug())

	// if passing an existing resource and naming, don't need the other params.
	protected function __construct($databaseNameOrResource , $userOrI5NamingFlag='' , $password='' , $transportType='', $isPersistent = false) {

		// get settings from INI file
		// TODO change getConfigValue to get many at one time 
        $xmlServiceLib = $this->getConfigValue('system', 'XMLServiceLib', 'ZENDSVR6');
        $helperLib = $this->getConfigValue('system', 'HelperLib', 'ZENDSVR6');
        $debug = $this->getConfigValue('system', 'debug', false);
        $debugLogFile = $this->getConfigValue('system', 'debugLogFile', false);
        $encoding = $this->getConfigValue('system', 'encoding', 'ISO-8859-1'); // XML encoding
        $sbmjobParams = $this->getConfigValue('system', 'sbmjob_params');
        $parseOnly = $this->getConfigValue('testing', 'parse_only', false);
        $parseDebugLevel = $this->getConfigValue('testing', 'parse_debug_level', null);
        
        
        // set service parameters to use in object.
        // Here are the params that will always be present.
		$serviceParams = array('XMLServiceLib'     => $xmlServiceLib,
		                       'HelperLib'         => $helperLib,
				               'debug'             => $debug,
                               'debugLogFile'      => $debugLogFile,
                               'encoding'          => $encoding,
				               'parseOnly'         => $parseOnly,
				               'parseDebugLevel'   => $parseDebugLevel);

		
		// Optional params. Don't specify if not given in INI.
		$optionalSystemParamNames = array('v5r4', 'ccsidBefore', 'ccsidAfter', 'useHex', 'paseCcsid', 'trace', 'dataStructureIntegrity',  'arrayIntegrity');
		foreach ($optionalSystemParamNames as $optionalSystemParamName) {
			$val = $this->getConfigValue('system', $optionalSystemParamName);
			if ($val) {
				$serviceParams[$optionalSystemParamName] = $val;
			}
			
		} //(foreach ($optionalSystemParamNames)
		
		// More optional params. From [transport] section
		$optionalSystemParamNames = array('httpTransportUrl', 'plugSize');
		if (!$transportType) {
			// transport type (http, ibm_db2, odbc) not passed into constructor. get from INI if avail.
			$optionalSystemParamNames[] = 'transportType';
		} else {
			// transport type was passed to constructor. Use it directly in param array.
			$serviceParams['transportType'] = $transportType;
		} //(if (!$transportType))	

		// look up the needed options in INI file.
		foreach ($optionalSystemParamNames as $optionalSystemParamName) {
		    $val = $this->getConfigValue('transport', $optionalSystemParamName);
			if ($val) {
			    $serviceParams[$optionalSystemParamName] = $val;
			}
				
		} //(foreach ($optionalSystemParamNames)
		    	
        
        if ($sbmjobParams) {
        	// optional. Don't specify if not given in INI.
            $serviceParams['sbmjobParams'] = $sbmjobParams;
        } //(if sbmjobParams)
        
        // set up options in this object. Includes debugging, logging, transport.
        $this->setOptions($serviceParams);

        // get transport type from options, wherever it came from.
       	$transportType = $this->getOption('transportType');
        
        if ($this->isDebug()) {
		    $this->debugLog("Creating new conn with database: '$databaseNameOrResource', user or i5 naming flag: '$userOrI5NamingFlag', transport: '$transportType', persistence: '$isPersistent'\n");
        }

		/*
		 * try {
    toolkit->callsomething($xml);
    echo 'Never get here';
}
catch (Exception $e)
{
    echo 'Exception caught: ',  $e->getCode(), " : ", $e->getMessage(),  "\n";
}
		 */

		  $this->chooseTransport($transportType);

		  $transport = $this->getTransport();
		  		  
		  // if db resource was passed in
		  if (is_resource($databaseNameOrResource)) {
		      // we already have a db connection, passed in by user.
		      $conn = $databaseNameOrResource;
		      $this->_i5NamingFlag = $userOrI5NamingFlag; // 0 or 1
		      // slash if true, dot if false.
		      $schemaSep = ($this->_i5NamingFlag) ? '/' : '.';
		      $this->setOptions(array('schemaSep' => $schemaSep) );

		      if ($this->isDebug()) {
		          $this->debugLog("Re-using an existing db connection with schema separator: $schemaSep");
		      }

		  // TODO could check type of object
		  } elseif ($transportType == 'http') {
		  	
		  	$databaseName = $databaseNameOrResource;
		  	$user = $userOrI5NamingFlag;
		  	$conn = $transport->connect( $databaseName, $user, $password);
		  
		  } else {
		  		
              // A DB transport was requested without providing an existing resource.
              // Create a new db connection.
		      $databaseName = $databaseNameOrResource;
		      $user = $userOrI5NamingFlag;
		      if ($this->isDebug()) {
		  	      $this->debugLog("Going to create a new db connection at " . date("Y-m-d H:i:s") . ".\n");
		  	      $startCreate = microtime(true);
		      }
		      $this->setIsPersistent($isPersistent);
		  	  $conn = $this->db->connect( $databaseName, $user, $password, array('persistent'=>$this->getIsPersistent()));
		  	  if ($this->isDebug()) {
		  	      $durationCreate = sprintf('%f', microtime(true) - $startCreate);
		  	  	  $this->debugLog("Did create a new db connection in $durationCreate seconds.");
		  	  }
		  	   
		  } //(is_resource)

        

		  if (!$conn) {
		  	    // added code in addition to message.
		  	    // need to get TRANSPORT's way to get an error.
		  	    // TODO add other transports, soap, etc. not just db.
		  	    // Should set error in the transport (db2),
		  	    // a common error routine in the base class, let's say.
		  	    // The subclasses can say why.
		  	    // make generic "geterrorcode" and "geterrormessage" methods.
		  	    // base class can have transportStateErrorMessage and tSECode
		  	    // and the adapters fill those in. Not sql-specific.
		  	    
		  	    // Note: SQLState 08001 (with or without SQLCODE=-30082) usually means invalid user or password. This is true for DB2 and ODBC.
		  	    $sqlState = $this->db->getErrorCode();
				$this->error = $this->db->getErrorMsg();

				$this->debugLog("\nFailed to connect. sqlState: $sqlState. error: $this->error");
				// added sqlstate
				throw new \Exception($this->error, (int)$sqlState);
		  }
		$this->conn = $conn;

		return $this; // for fluent interface
		
	} //(protected function __construct)

	public function __clone ()	{
		throw new \Exception(" Use getInstance() function according to create a new ToolkitService object");
	}

	// whether we're using CW (compatibility wrapper) or not
	public function setIsCw($isCw) 
	{
		$this->_isCw = $isCw;
	} //(function setIsCw)
	
	public function getIsCw() 
	{
		return $this->_isCw;
	} //(function getIsCw()
	

	// return array of valid plug sizes.
	// public method in case an application wishes to validate.
	public function validPlugSizes() {
		return array_keys($this->_dataSize);
	} ///(validPlugSizeArray)

	// valid plug sizes separated by commas. Useful for informational messages.
	protected function validPlugSizeList() {
		return implode($this->validPlugSizes(), ', ');
	}
	
	// return size in bytes based on plugSize.
	protected function plugSizeToBytes($plugSize) {

		// return size in bytes based on plugSize.
		if (isset($this->_dataSize[$plugSize])) {
			return $this->_dataSize[$plugSize];
		}
		
		throw new \Exception("plugSize '$plugSize' is not valid. Try one of these: " . $this->validPlugSizeList);

	} //(protected function plugSizeToBytes($size) )
	
	
	protected function setTransport($transportObject) {
		$this->_transport = $transportObject;
	} //(protected function setTransport)

	
    protected function getTransport() {
    	return $this->_transport;
    }
	
	protected function chooseTransport($transportName = '') {
		
		if ($transportName == 'http') {
			$transport =  new httpsupp();
			$this->setTransport($transport);
			
		} else {
			// not http. Assume it's one of the db transports
	        $this->setDb($transportName); // ibm_db2, odbc, http
		} //(if ($transportName == 'http'))
		
	} //(protected function chooseTransport($transportName = ''))
	
	
	// transport type is same as db extension name when a db transport is used.
	protected function setdb( $transportType = '')
	{
		$transportType = trim($transportType);
		
		// if extension is specified, use it; else use default db.
		$extensionName = ($transportType) ? $transportType : DBPROTOCOL; 

		if (!extension_loaded($extensionName)) {
			throw new \Exception("Extension $extensionName not loaded.");
		}
		
		// extension is loaded. Set up db transport objects.
		
		if ( $extensionName === 'ibm_db2') {

			    $this->setOptions(array('plugPrefix' => 'iPLUG'));
		        $this->db  = new db2supp();
		        
		        $this->setDb2(); // not used in toolkit anymore but keep for backwards compat.
		        
		        
		} elseif ($extensionName === 'odbc'){
			
			    //for odbc will be different default stored procedure call
			    $this->setOptions(array('plugPrefix' => 'iPLUGR')); // "R" = "result set" which is how ODBC driver returns param results
			    $this->db =  new odbcsupp();

		} //(extension name)

		
		// transport, too, to be generic
		$this->setTransport($this->db);
		
		return;
		
	} //(function setdb)
	
 
    // Also alias setOptions()
	public function setToolkitServiceParams ( array $XmlServiceOptions )
	{
		// copy incoming options to new array that we can safely manipulate
		$options = $XmlServiceOptions;
		
        // special cases first

	    /* If sbmjobParams is present, it must contain at least one slash. If not, do not process it.
	    *  The slash implies that subsystem name and subsytem decscription (and, optionally, job name)
		*  are present in the string
		*/
		if ( isset ($options['sbmjobParams']) && !strstr($options['sbmjobParams'], "/") ){
	        unset($options['sbmjobParams']);
		} //(if sbmjobParams is set but no slash)   	


		// if a plug name is passed in, it overrides plugPrefix and plugSize.
		if(isset ($options['plug']) && $options['plug']) {
		
			// TODO enumerate plug prefixes centrally, tied to db extension name, at top of this class
			$possiblePrefixes = array('iPLUG', 'iPLUGR');
			$options['plugSize'] = str_replace($possiblePrefixes, '', $options['plug']); // remove prefix to get size
			$options['plugPrefix'] = str_replace($options['plugSize'], '', $options['plug']); // remove size to get prefix

		} //(plug)
		
			
		// encoding provided but it's blank
		if( isset ($options['encoding']) && !$options['encoding']){
			unset($options['encoding']);
		}
		
        // verify that schemaSep is a valid character for this purpose
		if( isset ($options['schemaSep']) && !in_array($options['schemaSep'], $this->_validSeparators)) {
			unset($options['schemaSep']);
		}
		
		// handle case sensitivity. Put value in index of proper camel casing
		if( isset ($options['InternalKey'])) {
			$options['internalKey'] = $options['InternalKey'];
		}
		
		
		// now set all in a generic fashion
		// loop through all options provided in param
		foreach ($options as $optionName=>$optionValue) {
			
			if (isset($this->_options[$optionName])) {
				// it's valid. Set class property to its value.
				$this->_options[$optionName] = $optionValue;
				
			} //(if (isset($this->_validOptions[$optionName])))
		} //(foreach ($options as $optionName=>$propertyName))
        			   
	} //(setToolkitServiceParameters)


    // shorthand for getToolkitServiceParam()
    public function getOption($optionName) 
    {
	    return $this->getToolkitServiceParam($optionName);
    } //(getOption)

    // retrieve full toolkit option array
    public function getOptions()
    {
    	    return $this->_options;
    	
    } //(getOption)
    
    
    // shorthand for setToolkitServiceParams()
    public function setOptions($options = array()) 
    {
	    $this->setToolkitServiceParams($options);
	
    } //(setOptions)


    // get a single option value
	public function getToolkitServiceParam( $optionName ){
	    		    	
        // return property value if property is set. 
        // we use array_key_exists() rather than isset() because the value may be null.
        
		// special case, case sensitivity
		if ($optionName == 'InternalKey') {
			$optionName = 'internalKey';
		} //(	if ($optionName == 'InternalKey'))
		
        if (array_key_exists($optionName, $this->_options)) {
        	return $this->_options[$optionName];
        } //(if (array_key_exists($optionName, $this->_options))    

    	// nothing matched
        Throw new \Exception("Invalid option requested: $optionName");
    	
	} //(public function getToolkitServiceParam( $paramName ))

   // end job if private job (internal key set); end DB transport if not persistent.
	public function disconnect()
	{
		// if stateful connection, end the toolkit job.
		if (!$this->isStateless()) {
		    $this->PgmCall("OFF", NULL);
		}    

		// if transport is a db, end the db connection.
		if (isset($this->db) && $this->db) {
		    $this->db->disconnect($this->conn);
		}    
    	
		$this->conn = null;
	
	} //(public function disconnect())

	// same as disconnect but also really close persistent database connection.
	public function disconnectPersistent()
	{
		$this->PgmCall("OFF", NULL);

		if (isset($this->db) && $this->db) {
		    $this->db->disconnectPersistent($this->conn);
		}
		$this->conn = null;
	} //(public function disconnectPersistent())

    public function debugLog($stringToLog) {

    	if ($this->isDebug()) {
    	    error_log ( "$stringToLog",
	                    3, // means append
	                    $this->getOption('debugLogFile'));
		} //(debug)

    } //(debugLog)


    // isDb2 and setDb2 may not be needed. Deprecate in future.
	public function isDb2()
	{
	   return $this->db2;
	}

	public function setDb2()
	{
	   return $this->db2 = true;
	}

    // for special requests such as transport, performance, license
    public function specialCall($callType) 
    {
		$this->setOptions(array($callType=>true));
		$outputArray = $this->PgmCall("NONE", NULL, NULL ,NULL);
		$this->setOptions(array($callType=>false));
		
		return $outputArray;
	    
    } //(specialCall)

    public function callTransportOnly()
	{
		return $this->specialCall('transport');
	}

	public function performanceData()
	{
		return $this->specialCall('performance');
	}

    // return license/version information
	public function licenseXMLSERVICE()
	{
		return $this->specialCall('license');
	}


	/* pgmCall
	 * @param string        pgmName     Name of program to call, without library
	 * @param string        lib         Library of program. Leave blank to use library list or current library
	 * @param array|string  InputParam  An array of ProgramParameter objects OR XML representing params, to be sent as-is.
	 * @param array|ProgramParameter    ReturnValue Array of one parameter that's the return value parameter
	 * @param array         options     Array of other options. The most popular is 'func' indicating the name of a subprocedure or function. 
	 */
	public function pgmCall($pgmName, 
			                $lib,
	                        $inputParam =  NULL,
							$returnParam = NULL,
							$options = NULL )
	{

		$this->cpfErr = '';
		$this->error = '';
		$this->joblog = '';
		$disconnect  = false;
	    $optional  = false;
		$function = NULL;
		ProgramParameter::initializeFallbackVarName(); // in case any data elements don't have names
		 
		// If only one 'return' param, turn it into an array for later processing.
		if ($returnParam instanceof ProgramParameter) {
			$returnParam = array($returnParam);
		} //(// If only one 'return' param, turn it into an array for later processing.)
		
		
		$this->XMLWrapper = new XMLWrapper(array('encoding' => $this->getOption('encoding')),
		                                   $this);

	    // $optional handles special requests such as 'license'
	    $disconnect = ( strcmp ( $pgmName, "OFF" ) === 0) ? true : false;
	    $optional = ( strcmp ( $pgmName, "NONE" ) === 0) ? true : false;
  
	    $outputParamArray = false;
		
		if( isset($options['func']))/*call service program*/
		    $function = $options['func'];

		if ($disconnect || $optional) {
            // disconnect
			$inputXml = $this->XMLWrapper->disconnectXMLIn();
		} else {
			// regular request			
			$inputXml = $this->XMLWrapper->buildXmlIn($inputParam, $returnParam, $pgmName, $lib, $function);
		} //(if( $disconnect || $optional))
		
		// send XML to XMLSERVICE
		$outputXml = $this->sendXml($inputXml, $disconnect);

		// there should be some output, even if only an error
        if ($outputXml != '') {

			// see if real data came back
        	$outputParamArray = $this->XMLWrapper->getParamsFromXml( $outputXml );
			
        	// did we get results (array of regular in/out parms and return parms) ?
			if( !is_array($outputParamArray )){

				// No real data. Look for errors. Retrieve details from joblog.
				$this->joblog = $this->XMLWrapper->getLastJoblog();

				// get CPF messages
				// Also store full msg in toolkit log

				// include called program in list of pgms that might have generated a CPF error
				// also include '< lveContext' because it may appear in the program spot if library does not exist.
				// same for     '#mnrnrl' if program does not exist. 
				// and          'QRNXIE' for non-numeric data passed in numeric field.
				// and          '< allProgram' for when wrong number of params are passed.
				// TODO instead of all these pseudo-program names, take last error from XMLSERVICE parsing, if program name itself not found.
		        $programsToLookFor = array($pgmName, '< lveContext', '#mnrnrl', 'QRNXIE', '< allProgram'); // make $pgmname the first item in the array

				if (isset($this->_cpfMapping[$pgmName])) {
			        /* list of programs, in addition to the program that was called directly,
			         * that might generate CPF codes in joblog.
		            */
				    // add them to the mix
					// use array_merge because it discards indexes
					$programsToLookFor = array_merge($programsToLookFor, $this->_cpfMapping[$pgmName]);

				} //(if other cpf-making programs)

				// put values in $this->cpfErr and $this->error
	            $gotErrors = $this->extractErrorFromJoblog($programsToLookFor);

			} //(if( !is_array($OutputParamArray )))


		    // if got real parms back
         } //(if($outputXml != ''))


		 unset ( $this->XMLWrapper );
		 
		 // output array includes in/out parameters and return parameters.
		 return $outputParamArray;

	} //(function pgmCall)


	// __toString will help people accustomed to outputting a resource as string
	// and for testing
    public function __toString()
    {
    	$ipc = trim($this->getInternalKey());
    	$serviceLibrary = $this->getOption('XMLServiceLib');
    	$stringStart = "ToolkitService object using service library $serviceLibrary.";
    	$ipcInfo = ($ipc) ? "Internalkey: '$ipc'" : "Running stateless (inline, no IPC).";

    	return "$stringStart $ipcInfo";

    } //(__toString)
	
	public function getErrorMsg() {
		return $this->errorText;
	}
	public function getErrorCode() {
		return $this->cpfErr;
	}

	public function setErrorMsg($msg) {
		$this->errorText = $msg;
	}
	
	public function setErrorCode($code) {
		$this->cpfErr = $code;
	}
	
	
	
	public function getOutputParam(array $OutputArray)
	{
		if( !is_array($OutputArray))
		   return false;

		if( isset($OutputArray['io_param']))
			return $OutputArray['io_param'];

        return false;
	}

	// Send any XML to XMLSERVICE toolkit. The XML doesn't have to represent a program.
	// Was protected; made public to be usable by applications.
	public function ExecuteProgram( $inputXml, $disconnect=false )
	{

		$outputXml ='';
		$this->error = '';

		$this->VerifyPLUGName(); // calculates value of option 'plug'
		$this->VerifyInternalKey();


		// TODO create driver-specific SQL in driver classes (db2, odbc)
		$toolkitLib = $this->getOption('XMLServiceLib');
		$internalKey = $this->getInternalKey();
		$controlKeyString = $this->getControlKey($disconnect);

		$plugSize = $this->getOption('plugSize');
		
        $transportType = $this->getOption('transportType');
        		
		// TODO have one transport class that includes db as well.
		
		// If a database transport
		if (isset($this->db) && $this->db) {
			
		    $schemaSep = $this->getOption('schemaSep');
		    
		    $plugPrefix =  $this->getOption('plugPrefix');
		    // construct plug name from prefix + size
		    $plug = $plugPrefix . $plugSize; // e.g. iPLUG512K
		    
		    if( $plugPrefix == 'iPLUG') {
			    // db2 driver stored procedures take 4 params
			    $sql =  "call {$toolkitLib}{$schemaSep}{$plug}(?,?,?,?)";
		    }
		    else {	/*odbc, iPLUGR */
			    // only three params for odbc stored procedures
		        $sql =  "call {$toolkitLib}{$schemaSep}{$plug}(?,?,?)";
		    
		    } //(if( $plugPrefix == 'iPLUG'))
			
			$bindArray = array(
					"internalKey"=> $internalKey,
					"controlKey" => $controlKeyString,
					"inputXml" => $inputXml,
					"outputXml"=> '',
					"disconnect"=>$disconnect
			); //($bindArray)

			// if debug mode, log control key, stored procedure statement, and input XML.
			if( $this->isDebug() ) {
				$this->debugLog ( "\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() ."\nIPC: '" . $this->getInternalKey() . "'. Control key: $controlKeyString\nStmt: $sql with transport: $transportType\nInput XML: $inputXml\n");
				$start = microtime(true);
			} //(if debug)
					
			// can return false if prepare or exec failed.
			$outputXml = $this->db->execXMLStoredProcedure( $this->conn, $sql, $bindArray );
		
		} else {
			// Not a DB transport. At this time, assume HTTP transport (which doesn't use a plug, by the way. uses outbytesize)
			$transport = $this->getTransport();
			$transport->setIpc($internalKey);
			$transport->setCtl($controlKeyString);
			$url = $this->getOption('httpTransportUrl');			
			$transport->setUrl($url);
			
			
			// convert plugSize to bytes
			$outByteSize = $this->plugSizeToBytes($plugSize);

			// if debug mode, log control key, and input XML.
			if( $this->isDebug() ) {
				$this->debugLog( "\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() ."\nIPC: '" . $this->getInternalKey() . "'. Control key: $controlKeyString\nHost URL: $url\nExpected output size (plugSize): $plugSize or $outByteSize bytes\nInput XML: $inputXml\n");
				$start = microtime(true);
			} //(if debug)
					
			
			$outputXml = $transport->send($inputXml, $outByteSize );
				
		} //(if (isset($this->db) && $this->db))
		
		if ($this->isDebug()  && $outputXml) {
			$end = microtime(true);
			$elapsed = $end - $start;
			$this->debugLog("Output XML: $outputXml\nExec end: " .  date("Y-m-d H:i:s") . ". Seconds to execute: $elapsed.\n\n");
		} //(if debug and there's some output XML)

		// if false returned, was a database error (stored proc prepare or execute error)
		// TODO add ODBC SQL State codes
		
		// If can't find stored proc for ODBC: Database code (if any): S1000. Message: [unixODBC][IBM][System i Access ODBC Driver][DB2 for i5/OS]SQL0440 - Routine IPLUG512K in XMLSERVICE not found with specified parameters.
	//Warning: odbc_prepare(): SQL error: [unixODBC][IBM][System i Access ODBC Driver][DB2 for i5/OS]SQL0440 - Routine IPLUG512K in XMLSERVICE not found with specified parameters., SQL state S1000 in SQLPrepare in /usr/local/zend/ToolkitAPI/Odbcsupp.php on line 89	
		if($outputXml === false) {
			$this->cpfErr = $this->db->getErrorCode(); // actually SQL State
			$this->error = $this->db->getErrorMsg();
			
			$serviceLibrary = $this->getOption('XMLServiceLib');
            if ($this->cpfErr == 22001) {
                //22001 = On db2_execute, plug was too small to get input XML.
                $plug = $this->getOption('plug');
                $errorReason = "Error: XML input was too large for the current plug size, '$plugSize'. Set a larger plugSize.";
            } elseif ($this->cpfErr == 22003) {
                //22003 = On db2_execute, plug was too small to get output XML.
                $plug = $this->getOption('plug');
                $errorReason = "Error: XML output was too large for the current plug size, '$plugSize'. Set a larger plugSize.";
            } elseif ($this->cpfErr == 22501) {
            	//22501 = Probably missing the LOB DB2 PTF. Get the latest DB2 Group PTF or CUME.
            	// or individual PTF: 
            	//        V5R4: 5722SS1 SI39610
            	//         6.1: 5761SS1 SI39829
            	//         7.1: 5770SS1 SI39831/SI39917 
            	$errorReason = "Error: http://forums.zend.com/viewtopic.php?f=113&t=45413 Message: {$this->error}.";
            } elseif ($this->cpfErr == 38501) {
                // SQLState 38501: error in stored procedure. Possibly trace=true but library XMLSERVLOG doesn't exist.            
                //          or     Trigger program or external routine detected an error. SQLCODE=-443
                $errorReason = "Error: SQLState 38501. Message: {$this->error}. Error in stored procedure or program. Could be a library that does not exist. If trace=true (not debug--trace), make sure XMLSERVLOG exists.";
            } elseif ($this->cpfErr == 42704) {
            	//42704 = obj not found
            	$errorReason = "Error: Toolkit not found in specified service library ($serviceLibrary).";
            } elseif ($this->cpfErr == 42833) {
                //42833 = The qualified object name is inconsistent with the naming option.
                $errorReason = "Error: i5_naming mismatch. When connecting to the toolkit, you specified i5_naming='$this->_i5NamingFlag' (or left the default of 0), which does not match the naming mode of the database job. Solution: If you are using a persistent database connection, ensure that every time you connect to db2 or the toolkit with a given user profile, you specify the same naming value for 'i5_naming'. If you are using library lists or a schema separator of '/', the naming mode must be '1'.";
            } elseif ($this->cpfErr == 58004) {
                //58004 = The qualified object name is inconsistent with the naming option.
                $errorReason = "Error:  Message: {$this->error}. SQLState 58004. If SQLCode is -901, check previous messages in joblog. Could mean an incorrect library in library list or another previous error in database job.";
            } elseif ($this->cpfErr == '' || $this->cpfErr == 'HY017') {
                // no SQLSTATE or HY017: The DB2 QSQSRVR job no longer exists.
            	    $errorReason = "Error: SQLSTATE='{$this->cpfErr}' and Message: '{$this->error}', indicating that this PHP job's associated database job is no longer running.";
            } else {
			    $errorReason = "Toolkit request failed. Review the database code and message.";
	            $errorReason .= " Database code (if any): '{$this->cpfErr}'. Message: {$this->error}";
            } //(if error == 42704)

            // other codes: SQLState 38501: error in stored procedure. Possibly trace=true but library XMLSERVLOG doesn't exist.            
            //                       38501: Trigger program or external routine detected an error. SQLCODE=-443 
            //                              could be bad library in libl.                        
            //    in joblog, see:
            /* CPF2110  Library GLUMP not found.  
             * then:
             * SQL0443 Message . . . . :   Trigger program or external routine detected an error.    
                                                                              
Cause . . . . . :   Either a trigger program, external procedure, or external 
  function detected and returned an error to SQL. If the error occurred in a  
  trigger program, the trigger was on table QCMDEXC in schema QSYS. If the    
  error occurred in an external procedure or function, the external name is   
  QCMDEXC in schema QSYS.  The associated text is Library GLUMP not found..   
  If the error occurred in a trigger program, the associated text is the type 
  of trigger program.  If the error occurred in an external function, the     
  associated text is the text of the error message returned from the external 
  function.                                                                   
             */
			logThis($errorReason);
	        die($errorReason);

		} //(if($outputXml === false) )


		if( $disconnect ) {
		    $this->db->disconnect($this->conn);

		    if ($this->isDebug()) {
			    $this->debugLog("Db disconnect requested and done.\n");
		    } //(debug)
		} //(disconnect)

		// workaround: XMLSERVICE as of 1.7.4 returns a single space instead of empty string when no content was requested.
		if ($outputXml == ' ') {
			$outputXml = '';
		} //(if ($outputXml == ' '))
		
		return $outputXml;

	} //(ExecuteProgram)

	// Alias of ExecuteProgram();
	// Send any XML to XMLSERVICE toolkit. The XML doesn't have to represent a program.
	// Return output XML.
	// TODO create method to parse XML appropriately no matter what type of tags (cmd/pgm etc.)
	public function sendXml( $inputXml, $disconnect=false )
    {
	    return $this->ExecuteProgram($inputXml, $disconnect);
	
    } //(sendRequest)

    
    // factory pattern.
    protected function getXmlWrapper() 
    {
    	return new XMLWrapper(array('encoding' => $this->getOption('encoding')),
		                                   $this);
    }  //(protected function getXmlWrapper())
    
    // $info can be 'joblog' (joblog and additional info) or 'conf' (if custom config info set up in PLUGCONF)
    // Return array of version, joblog, job info
    public function getDiagnostics($info = 'joblog', $jobName = '', $jobUser = '', $jobNumber = '') 
    {
        $xmlWrapper = $this->getXmlWrapper();

        $inputXml = $xmlWrapper->diagnosticsXmlIn($info, $jobName, $jobUser, $jobNumber);
        
        // set stored procedure "plug"
        $this->verifyPLUGName();
        
        // send the XML, running the command
        $outputXml = $this->sendXml( $inputXml, false );

        if ($outputXml) {
        	
        	$this->cpfErr = 0;
        	$this->error = '';
        	 
        	return $xmlWrapper->parseDiagnosticsXml($outputXml);
        	
        } else {
        	
        	// error or no info
     		$this->cpfErr = $this->XMLWrapper->getErrorCode();
     		$this->error = $this->cpfErr; // ->error is ambiguous. Include for backward compat.
     		$this->errorText = $this->XMLWrapper->getErrorMsg();
     		return false;
     		
        } //(if ($outputXml) )
        
                // get status: error or success, with a real CPF error message, and set the error code/msg.
//        $successFlag = $this->XMLWrapper->getCmdResultFromXml( $outputXml, $parentTag);
        
        
        
    } //(public function getDiagnostics)
     

    /**
     * Return version number of the PHP toolkit (front-end).
     * @return string  Version number (e.g. '1.4.0')
     */
    static function getFrontEndVersion()
    {
        return self::VERSION;
        
    } //(static function getFrontendVersion())
    
    
    // return version number of XMLSERVICE. Not static because must connect to back-end to get the version number.
    public function getBackEndVersion() {
    	
        	$diag = $this->getDiagnostics();
    	
        if (isset($diag['version'])) {
    		    return $diag['version'];
    	    } else {
    		    return false;
        	} //(if (isset($diag['version'])))
    	
    } //(public function getBackendVersion())
    
    /**
     * Return version number of the local installation of XMLSERVICE, if available.
     * Static because don't have to connect or instantiate toolkit object.
     * Uses 'exec' command to retrieve local version number.
     * Requires 1.8.0+ of XMLSERVICE and new program introduced with it: xmlver.pgm.
     * @return string  Version number (e.g. '1.8.0')
     */
    static function getLocalBackEndVersion($library) {

        $cmd = "qsh -c /qsys.lib/$library.lib/xmlver.pgm";
        	
        // will return false on error, or the version number if successful.
        // Note: the web server user must have permissions to the XMLVER program. 
        $version = exec($cmd); // exec() returns last line of output from command
    	 
    	    // if unable to get version
        if (!$version) { // false or empty
        	    return "Cannot get version number for XMLSERVICE in library '$library' using program XMLVER. Check the library, permissions of the web server user, and that XMLSERVICE is at least v1.8.0+, when XMLVER was introduced.";
        } //(if (!$version))
        
        return $version;
           	 
    } //(public function getLocalBackendVersion())
    
	
	
	// exec could be 'pase', 'pasecmd', 'system,' 'rexx', or 'cmd'
	// $command can be a string or an array of multiple commands
	public function CLCommand($command, $exec = '') {

		$this->XMLWrapper = new XMLWrapper(array('encoding' => $this->getOption('encoding')),
		                                   $this);

		$this->cpfErr = '0';
		$this->error = '';
		$this->errorText = '';
		
		$inputXml = $this->XMLWrapper->buildCommandXmlIn($command, $exec);

		// rexx and pase are the ways we might get data back.
		$expectDataOutput = in_array($exec, array('rexx', 'pase', 'pasecmd'));
        
		// if a PASE command is to be run, the tag will be 'sh'. Otherwise, 'cmd'.
		if ($exec == 'pase' || $exec == 'pasecmd') {
			$parentTag = 'sh';
		} else {
			$parentTag = 'cmd';
		} //(if ($exec == 'pase' || $exec = 'pasecmd'))
		
		$this->VerifyPLUGName();

		// send the XML, running the command
		$outputXml = $this->sendXml( $inputXml, false );

		// get status: error or success, with a real CPF error message, and set the error code/msg.
		$successFlag = $this->XMLWrapper->getCmdResultFromXml( $outputXml, $parentTag);

		if ($successFlag) {
			$this->cpfErr = 0;
			$this->error = '';
		} else {
		    $this->cpfErr = $this->XMLWrapper->getErrorCode();
		    $this->error = $this->cpfErr; // ->error is ambiguous. Include for backward compat.
		    $this->errorText = $this->XMLWrapper->getErrorMsg();
		} //(if ($successFlag))

 	    if ($successFlag && $expectDataOutput) {
            
 	    	// if we expect to receive data, extract it from the XML and return it.
		    $outputParamArray = $this->XMLWrapper->getRowsFromXml( $outputXml, $parentTag);

		    unset($this->XMLWrapper);
		    return $outputParamArray;
	    } else {
		    // don't expect data. Return true/false (success);
		    unset($this->XMLWrapper);
		    return $successFlag;
	    } //(if success and expect data)

	} //(CLCommand)

    public function CLInteractiveCommand($command) {

    	return $this->CLCommand($command, 'pase');
    }


    public function paseCommand($command) {
    
    	return $this->CLCommand($command, 'pasecmd');
    }
    
    
    public function qshellCommand($command) {

    	// send a command through the QSH interpreter
    	// and interpret error results.

    	// Handle errors and combine array-based results into a single string.

    	// TODO consider doubling user-supplied single quotes to escape them in QSH

    	$qshCommand = "QSH CMD('$command')";
    	 
    	// will return an array of results.
    	$resultArray = $this->CLInteractiveCommand($qshCommand);
    	 
    	if (empty($resultArray) || !is_array($resultArray)) {
    		logThis("Result of QSH command $qshCommand is empty or not an array.");
    		return false;
    	}

    	// get status line
    	$firstLine = trim($resultArray[0]);

    	/* possible first line:
    	 * QSH0005: Command ended normally with exit status 0.  [means A-OK]
    	 * QSH0005: Command ended normally with exit status 1.  [look for a CPF message in next line]
    	 * QSH0005: Command ended normally with exit status 127. [problem finding command]
    	 * QSH0006: Command was ended by signal number yyy
    	 * QSH0007: Command was ended by an exception [haven't seen this one yet]
    	*/

    	$qshCode = substr($firstLine, 0, 7);

    	switch ($qshCode) {
 
    		case 'QSH0005':
    			/* get status code.
    			 * String will be something like QSH0005: Command ended normally with exit status 1.
    			 * But in German, QSH0005: Befehl wurde normal mit Ausfuehrungsstatus 1 beendet.
    			 * Look for a number between two word boundaries (\b is word boundary).
    			 * The word boundary (\b) is zero-length, so only the digits will be captured by the regex.
    			 */
    			$pattern = '/(\b[\d]+\b)/';
	        // look for a match
	        $numMatches = preg_match($pattern, $firstLine, $matches);

    			if ($numMatches) {
    			    $exitStatus = $matches[1]; // replacement parenthetical bit, i.e. the number.
    			} else {
    			    $this->cpfErr = $qshCode;
    			    $this->error = 'Could not get exit code. Check toolkit error log for error.';
    			    logThis("Result of QSH command $qshCommand was error: $firstLine.");
    				return false;
    			}

    			if ($exitStatus == '0') {

    				// SUCCESS!!!
    				// everything is fine.
    				// Return the rest of the array (without the status line).
    				if (count($resultArray) > 1) {
    					return array_slice($resultArray, 1);
    				} //(count > 1)

    			} else {
    				// look for a CPF code in second line. May not always be there.
    				// will resemble: catsplf: 001-2003 Error CPF3492 found processing spool file QSYSPRT, number 2.
    				//            or: catsplf: 001-2373 Job 579272/QTMHHTP1/WSURVEY400 was not found."
    				//
    				// TODO extract CPF code.
    				// TODO distinguish between status 1 and 127, if helpful
    				if (isset($resultArray[1])) {
    					$secondLine = trim($resultArray[1]);
    					$this->cpfErr = $secondLine;
    					return false;
    				}
    			} //(exitStatus)
    			/*} elseif ($exitStatus == '127') {
    				// look for errmsg in second line (e.g. cannot find command)
    			} //(if $exitStatus)
    			*/



    			break;

    		case 'QSH0006':
    		case 'QSH0007':
    			$this->cpfErr = $qshCode;
    			$this->error = 'Check toolkit error log for error.';
    			logThis("Result of QSH command $qshCommand was error: $firstLine.");
    			return false;
    			break;
    	} //(switch $qshcode)


    } //(qshellCommand)


	// new. uses REXX to return output params and CPF codes
	// Slower than 'cmd' or 'system'
	// Sample format of command: 'RTVJOBA JOB(?) USER(?) NBR(?) CURUSER(?) SYSLIBL(?) CURLIB(?) USRLIBL(?) LANGID(?) CNTRYID(?) CCSID(?N) DFTCCSID(?N)'
	public function ClCommandWithOutput($command) {

	    return $this->CLCommand($command, 'rexx');
	} //(ClCommandWithOutput)

	// new. uses 'system' to return CPF codes
	// slightly slower than regular cmd but faster than rexx
	// (Actually it's faster than cmd in recent tests. It depends, perhaps.)
	// $command can be a string or an array.
	public function ClCommandWithCpf($command) {

		return $this->CLCommand($command, 'system');
	} //(ClCommandWithCpf)



	static function AddParameter($type, $io, $comment, $varName = '', $value = '', $varying = 'off', $dimension = 0) {
		return array ('type' => $type,       // storage
					  'io' => $io,           // in/out/both
					  'comment' => $comment, // comment
		              'var' =>  $varName,    // variable name 
					  'data' => $value,      // value 
					  'varying' => $varying, // varying on/varying off 
					  'dim' =>   $dimension);// number of array elements
	}

    static function AddParameterChar( $io, $size , $comment,  $varName = '', $value= '', $varying = 'off',$dimension = 0,
    		                          $by='', $isArray = false, $ccsidBefore = '', $ccsidAfter = '', $useHex = false) {
    		return new CharParam( $io, $size , $comment,  $varName, $value , $varying ,$dimension, 
    				                $isArray, $ccsidBefore, $ccsidAfter, $useHex);
   	}

	static function AddParameterInt32( $io,  $comment,  $varName = '', $value = '', $dimension = 0 ) {
		return new Int32Param ($io, $comment, $varName, $value, $dimension);
	}
    //Size ($comment,  $varName = '', $labelFindLen = null) {
	static function AddParameterSize($comment,  $varName = '', $labelFindLen ) {
		return new SizeParam ($comment, $varName, $labelFindLen);
	}

	//SizePack5 ($comment,  $varName = '', $labelFindLen = null) {
	static function AddParameterSizePack($comment,  $varName = '', $labelFindLen ) {
		return new SizePackParam ($comment, $varName, $labelFindLen);
	}


	static function AddParameterInt64( $io,  $comment,  $varName = '', $value = '', $dimension = 0 ) {
		return new Int64Param( $io, $comment, $varName, $value, $dimension);
	}

	static function AddParameterUInt32( $io,  $comment,  $varName = '', $value = '', $dimension =0) {
		return new  UInt32Param ($io, $comment, $varName, $value, $dimension) ; // removed erroneous "off"
	}
	
	static function AddParameterUInt64( $io,  $comment,  $varName = '', $value='', $dimension=0 ) {
		return new UInt64Param($io, $comment, $varName, $value, $dimension);

	}
	static function AddParameterFloat( $io,  $comment,  $varName = '', $value='', $dimension=0 ) {
		return( new FloatParam($io, $comment, $varName, $value, $dimension));
	}

	static function AddParameterReal( $io,  $comment,  $varName = '', $value='', $dimension=0 ) {
		return new RealParam($io, $comment, $varName, $value, $dimension);
 	}

    static function AddParameterPackDec( $io, $length ,$scale , $comment,  $varName = '', $value='', $dimension=0) {
    	return new PackedDecParam($io, $length ,$scale , $comment,  $varName, $value, $dimension);
	}

    static function AddParameterZoned( $io, $length ,$scale , $comment,  $varName = '', $value='', $dimension=0) {
    	return new ZonedParam($io, $length ,$scale , $comment,  $varName , $value, $dimension);
	}

	// "hole" paramter is for data to ignore
	static function AddParameterHole( $size , $comment='hole') {
    		return new HoleParam( $size, $comment);
   	}


    static function AddParameterBin( $io, $size , $comment,  $varName = '', $value='',$dimension =0) {
    	return new BinParam($io, $size , $comment,  $varName, $value,$dimension);
	}
	static function AddParameterArray($array){
		foreach ($array as $element)
		{
			$params[] = self::AddParameter($element['type'],
										   $element['io'],
										   $element['comment'],
				        			       $element['var'],
				        			       $element['data'],
				        			       $element['varying'],
				        			       $element['dim']);
		}
		return $params;
	}

	static function AddDataStruct(array $parameters, $name='struct_name', $dim=0, $by='', $isArray=false, $labelLen = null, $comment = '', $io = 'both'){
		return new DataStructure($parameters, $name, $dim, $comment, $by, $isArray, $labelLen, $io);
	}

	// added.
	static function AddErrorDataStruct(){
		return new DataStructure(self::GenerateErrorParameter(), 'errorDs', 0);
	}

	// use this one when you need a zero-byte error structure,
	// which is useful to force errors to bubble up to joblog,
	// where you can get more information than in the structure.
	static function AddErrorDataStructZeroBytes(){
		return new DataStructure(self::GenerateErrorParameterZeroBytes(), 'errorDs', 0);
	}



	// pure XML version
	// Pass in $paramNum to get a numeric parameter number for the comment.
/*	static function getErrorDataStructXml($paramNum = 0) {
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';
		return "<parm io='both' comment='$paramNumStr Error code structure'>
                 <ds var='errorDs'>
                   <data var='errbytes' type='10i0' comment='Size of DS'>144</data>
                   <data var='err_bytes_avail' type='10i0' comment='if non-zero, an error occurred' />
                   <data var='exceptId' type='7A' varying='off' comment='CPF code'>0000000</data>
                   <data var='reserved' type='1h' varying='off' />
                   <data var='excData' type='128a' varying='off' comment='replacement data. Not sure we want it.  Causes problems in XML (binary data in there?).' />
                 </ds>
              </parm>";
	}
*/
	// use a zero (0) bytes length to force errors to bubble up to job. It's easier for us to get full message text from joblog that XMLSERVICE toolkit provides.
	// Anyway, the QSNDDTAQ API doesn't have an error struct, so this way we can be consistent---get all errors in joblog.
	static function getErrorDataStructXml($paramNum = 0) {
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';
		return "<parm io='both' comment='$paramNumStr Error code structure'>
                 <ds var='errorDs'>
                   <data var='errbytes' type='10i0' comment='Size of DS. Use 0 to force errors to bubble up to the job'>0</data>
                 </ds>
              </parm>";
	}

	// This version will provide the error code in output rather than forcing errors to bubble up to joblog.
	// Since XMLSERVICE is slow at getting job log, it's faster to get the code in the API DS if available.
	// Pass in $paramNum to get a numeric parameter number for the comment.
	static function getErrorDataStructXmlWithCode($paramNum = 0) {
	    $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';
	    return "<parm io='both' comment='$paramNumStr Error code structure'>
	<ds var='errorDs'>
	<data var='errbytes' type='10i0' comment='Size of DS'>16</data>
	<data var='err_bytes_avail' type='10i0' comment='if non-zero, an error occurred' />
	<data var='exceptId' type='7A' comment='CPF code'>0000000</data>
	<data var='reserved' type='1h' />
	</ds>
	</parm>";
	} //(getErrorDataStructXmlWithCode)
	

	// this DS is common to many IBM i APIs.
	static function getListInfoApiXml($paramNum = 0)
	{
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

		return "<parm io='out' comment='$paramNumStr List information'>
		    <ds var='listinfo' comment='Open list information format (common to all lists)'>
		     <data var='totalRecords' comment='Total records' type='10i0' />
		     <data var='returnedRecords' comment='Records returned' type='10i0' />
		     <data var='requestHandle' comment='Request handle: binary/hex' type='4b' />
		     <data var='recordLength' comment='Record length' type='10i0' />
		     <data var='infoComplete' comment='Information complete indicator. C=complete, I=incomplete, P=partial, more to get in Get List Entries' type='1a' />
		     <data var='timeAndDateCreated' comment='Time and date created' type='13a' />
		     <data var='listStatus' comment='List status indicator' type='1a' />
		     <data var='reserved' comment='Reserved' type='1h' />
		     <data var='lengthReturned' comment='Length of information returned' type='10i0' />
		     <data var='firstRecordNumber' comment='Number of first record returned in receiver variable' type='10i0' />
		     <data var='reserved2' comment='Reserved (another one)' type='40h' />
		    </ds>
		  </parm>";
	} //(getListApiXml)

	// this DS is common to many IBM i APIs.
	static function getNumberOfRecordsDesiredApiXml($paramNum = 0)
	{
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

		return "<parm io='in' comment='$paramNumStr Number of records to return. Use zero to offload to Get List Entries API'>
                  <data var='numRecsDesired' type='10i0'>0</data>
                </parm>";
	} //(getNumberOfRecordsDesiredApiXml)

	// this DS is common to many IBM i APIs.
	static function getSortInformationApiXml($paramNum = 0)
	{
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

		// assume no sort is required. Could add a sort in future if needed.
		return "<parm io='in' comment='$paramNumStr Sort information' >
                 <ds var='sortInfo'>
                   <data var='numSortKeys' comment='Number of keys to sort on. Use zero' type='10i0'>0</data>
                 </ds>
               </parm>
		";
	} //(getSortInformationApiXml)

	// this DS is common to many IBM i APIs.
	static function getDummyReceiverAndLengthApiXml($paramNum = 1, $lengthOfReceiverVariable)
	{
		$paramNumStr = $paramNum . '.';
		$paramNumStrNext = ($paramNum + 1) . '.';

		// assume no sort is required. Could add a sort in future if needed.
		return "<parm io='out' comment='$paramNumStr receiver. do not actually receive anything here. Wait till Get List Entry'>
                  <ds var='receiver' comment='length $lengthOfReceiverVariable'>
                    <data type='1h' comment='dummy. Real receiver will be gotten in list entry API call' />
                  </ds>
                </parm>
                <parm io='in' comment='$paramNumStrNext Length of receiver variable (actual structure to be given in Get List Entry)'>
                  <data var='receiverLen' type='10i0' comment='length $lengthOfReceiverVariable'>$lengthOfReceiverVariable</data>
                </parm>";
	} //(getSortInformationApiXml)


	public function getLastError() {
		return $this->error;
	}

	public function isError() {
		if($this->error != '')
			return true;
		return false;
	}

	public function getInternalKey(){
		return $this->getOption('internalKey');
	}
	
	public function isStateless() 
	{
		return $this->getOption('stateless');
	}
	
	public function setInternalKey($internalKey) {
		$this->setOptions(array('internalKey' => $internalKey));
	}

	// construct a string of space-delimited control keys based on properties of this class.
	protected function getControlKey($disconnect = false){

		$key = ''; // initialize

		if( $disconnect ){
		    return "*immed";
		}
		/*
		if(?) *justproc
		if(?) *debug
		if(?) *debugproc
		if(?) *nostart
		if(?) *rpt*/

        // Idle timeout supported by XMLSERVICE 1.62
	    // setting idle for *sbmjob protects the time taken by program calls
	    // Do that with *idle(30/kill) or whatever the time in seconds.
   	    if( trim($this->getOption('idleTimeout') ) != '' ) {
	        $idleTimeout = $this->getOption('idleTimeout');
			$key .= " *idle($idleTimeout/kill)"; // ends idle only, but could end MSGW with *call(30/kill)
	    }

	    // if cdata requested, request it. XMLSERVICE will then wrap all output in CDATA tags.
	    if( $this->getOption('cdata') ) {
			$key .= " *cdata";
	    }

		/* stateless calls in stored procedure job
		 *
		 * Add *here, which will run everything inside the current PHP/transport job
		 * without spawning or submitting a separate XTOOLKIT job.
		 */
	    if ($this->isStateless()) {
			$key .= " *here";

	    } else {
	    	// not stateless, so could make sense to supply *sbmjob parameters for spawning a separate job.
		    if( trim($this->getOption('sbmjobParams') ) != '' ) {
			   $sbmjobParams = $this->getOption('sbmjobParams');
			   $key .= " *sbmjob($sbmjobParams)";
	        } //(if subsystem *sbmjob specified)

		} //(if stateless)

		
		// if internal XMLSERVICE tracing, into database table XMLSERVLOG/LOG, is desired
		if ($this->getOption('trace')) {
			$key .= " *log";
		} //(if ($this->_trace))

		// directive not to run any program, but to parse XML and return parsed output, including dim/dou.
		if ($this->getOption('parseOnly')) {
			$key .= " *test";
			
			// add a debugging level (1-9) to the parse, to make *test(n) where n is the debugging level
			if ($parseDebugLevel = $this->getOption('parseDebugLevel')) {
				$key .= "($parseDebugLevel)";
			} //(if ($this->_parseDebugLevel) )
			
			
		} //(if ($this->_trace))
		

		// return XMLSERVICE version/license information (no XML calls)
		if ($this->getOption('license')) {
			$key .= " *license";
		} //($this->getOption('license'))
		
		// check proc call speed (no XML calls)
		if ($this->getOption('transport')) {
			$key .= " *justproc";
		} //($this->getOption('transport'))
		
		
		// get performance of last call data (no XML calls)
		if ($this->getOption('performance')) {
			$key .= " *rpt";
		} //($this->getOption('performance'))
		
		// *fly is number of ticks of each operation. *nofly is the default
		if ($this->getOption('timeReport')) {
			$key .= " *fly";
		} //($this->getOption('timeReport'))
		
		
		// PASE CCSID for <sh> type of functions such as WRKACTJOB ('system' command in PASE)
		if ($paseCcsid = $this->getOption('paseCcsid')) {
			$key .= " *pase($paseCcsid)";
		} //($this->getOption('performance'))
		
		// allow custom control keys
		if ($this->getOption('customControl')) {
			$key .= " {$this->getOption('customControl')}";
		} //($this->getOption('customControl'))
		
		return trim($key); // trim off any extra blanks on beginning or end

	} //(getControlKey)

//to set a plug name use function setToolkitServiceParams('plug'=>'iPLUGR512K')

	protected function VerifyPLUGName ()
	{
		// if plug already set, don't need to set it now.
		if($this->getOption('plug') != ''){
		    return;
		}
		//Sets the default plug.
		$size = 512;
		$unit = 'K';//or M

		/*4K, 32K, 65K, 512K, 
          1M, 5M, 10M up to 15M ...*/

		//in case that following SQL error error:
		//Length in a varying-length or LOB host variable not valid. SQLCODE=-311
		//verify that all last blob ptfs are applied on i5 machine
		//set the $this->plug = "iPLUG4K";,
		//it calls the program that returns data via char storage
		$plug = $this->getOption('plugPrefix') . $size . $unit;
		$this->setOptions(array('plug' => $plug));

	} //(VerifyPLUGName)


    // Ensures that an IPC has been set. If not, generate one
	protected function verifyInternalKey(){
        // if we are running in stateless mode, there's no need for an IPC key.
	    if ($this->isStateless()) {
	    	$this->setInternalKey('');
  	        return;
	    }

 		if(trim($this->getInternalKey()) == ''){
	 		if(session_id() != '' )/*if programmer already started session, use it*/
	 			$this->setInternalKey("/tmp/".session_id());
	 		else
				$this->setInternalKey("/tmp/". $this->generate_name());
		}
	} //(verifyInternalKey())
	
  // was protected. Changed to public.
  // May be useful to access raw XML result 
  // TODO make outputXml a property that is used so this method can work.
  public function getXmlOut() {
		return $this->outputXml;
	}

  // return transport object for toolkit
  public function getConnection()
  {
  	return  $this->conn;
  }

  public function generate_name()
	{/*move to i5 side*/
		$localtime = localtime();
	    $rndName = sprintf( "ZS%d%d%d%d",
					 $localtime[0],/*s*/
					 $localtime[1],/*min*/
					 $localtime[2],/*our*/
					 $localtime[3] /*day*/
					  );
		return $rndName;
 }
 /*creates Data structure that going to be used in lot of
  * i5 API's for error handling                         */
  static function GenerateErrorParameter()
  {
	    $ErrBytes   = 144;
		$ErrBytesAv = 144;
		$ErrCPF     = '0000000';
		$ErrRes     = ' ';
		$ErrEx      = ' ';
		// changed $this to self so can work in static context
		$ds[] = self::AddParameterInt32('in',  "Bytes provided", 'errbytes', $ErrBytes);
		$ds[] = self::AddParameterInt32('out', "Bytes available",'err_bytes_avail', $ErrBytesAv);
		$ds[] = self::AddParameterChar('out',7, "Exception ID",   'exceptId', $ErrCPF);
		$ds[] = self::AddParameterChar('out',1, "Reserved",       'reserved', $ErrRes);
		$ds[] = self::AddParameterHole('out',128, "Exception data", 'excData',  $ErrEx); // can be bad XML so make it a hole
		return $ds;
  }

  // specify zero bytes so error bubbles up to joblog where we can get description, etc.
  // TODO return 'in'-only data structure containing the int.
  static function GenerateErrorParameterZeroBytes()
  {
	    $ErrBytes   = 0;
		// changed $this to self so can work in static context
		$ds[] = self::AddParameterInt32('in',  "Bytes provided (zero makes errors bubble up to joblog)", 'errbytes', $ErrBytes);
	    return $ds;
  }


  	public function verify_CPFError( $retPgmArr, $functionErrMsg )
	{
		// it's an error if we didn't get output array at all
		// in that case, look for general "error" material

		// $functionErrMsg is obsolete now.

        if(!is_array($retPgmArr)){
        	$this->error = $this->getLastError();
            return true;
        }

		$retArr = $retPgmArr['io_param'];

		// get errorDs from named ds (CW style) or directly (PHP toolkit style)
		$errorDs = (isset($retArr['errorDs'])) ? $retArr['errorDs'] : $retArr;

		// If there's an error structure and some error info was returned.
		// (err_bytes_avail is the official, reliable way to check for an error.)
		if( isset($errorDs) && ($errorDs['err_bytes_avail'] > 0)){
		    $this->cpfErr = $errorDs['exceptId'];
		    // TODO future, get actual error text from joblog
		    $this->error = $functionErrMsg;
			return true;  //some problem
		} else {
				// no CPF error detected.
				$this->cpfErr = '0000000';
				$this->error = '';
				return false;
	    }
	} //(verify_CPFError)


  public function ParseErrorParameter( array $Error )
  {
  	if(!is_array($Error))
  	    return false;

	// If there's an error structure and some error info was returned.
	// (err_bytes_avail is the official, reliable way to check for an error.)
  	if( isset ($Error['exceptId']) && ($Error['err_bytes_avail'] > 0)){
  		$CPFErr = $Error['exceptId'];
  		/*Add here array parse if need */
  	}
  	return $CPFErr;
  }
  // for sql calls via already opened connection.
  // Clearer naming than existing getConnection();
  // TODO Probably even better would be a name such as getTransportConn() because it could work for any transport type. 
  public function getSQLConnection()
  {
		return $this->getConnection(); 
   }

 
  public function executeQuery($stmt){
  	 $Txt = $this->db->executeQuery($this->getConnection(), $stmt);

  	 if(!is_array($Txt)){

  	   		$this->cpfErr = $this->db->getErrorCode();
  	   		$this->error = $this->db->getErrorMsg();
  	   	
  	   		throw new \Exception($this->error, (int)$this->cpfErr);
  	 }
     return $Txt;
  }

  	public function setIsPersistent($isPersistent = false)
	{
		if (is_bool($isPersistent)) {
			$this->_isPersistent = $isPersistent;
		} else {
			throw new \Exception("setIsPersistent: boolean expected");
		}
	} //(setIsPersistent)

	public function getIsPersistent()
	{
		return $this->_isPersistent;
	} //(setIsPersistent)

	/* Method: getJobAttributes()
	 *
	 * Retrieve several attributes of the current job.
	 * Return array of attributes (key/value pairs) or false if unsuccessful.
	 * Purpose: 1. Helps user find toolkit job; identifies libraries and CCSID used by toolkit connection
	 *          2. The code is an example of how to get output from RTV* CL commands
	 * Sample output:
	 * Array(
          [JOB] => QSQSRVR
          [USER] => QUSER
          [NBR] => 240164
          [CURUSER] => QTMHHTTP
          [SYSLIBL] => QSYS       QSYS2      QHLPSYS    QUSRSYS    DBU80      QSYS38
          [CURLIB] => *NONE
          [USRLIBL] => QTEMP      QGPL       MYUTIL
          [LANGID] => ENU
          [CNTRYID] => US
          [CCSID] => 37
          [DFTCCSID] => 37)
	 */
	public function getJobAttributes() {

	    // Retrieve job attributes. Note: the CCSID attributes use (?N), not (?), because they are numeric.
        $cmdString = 'RTVJOBA JOB(?) USER(?) NBR(?) CURUSER(?) SYSLIBL(?) CURLIB(?) USRLIBL(?) LANGID(?) CNTRYID(?) CCSID(?N) DFTCCSID(?N)';

        // Send the command; get output array of key/value pairs. Example: CURUSER=>FRED, ...
        $outputArray = $this->ClCommandWithOutput($cmdString);

        return $outputArray;

	} //(public function getJobAttributes())


	/* classPath(). for diagnostics, return the file system absolute path of this script.
	 * Usage: echo 'The path of ToolkitService.php is: ' . ToolkitService::classPath();
	 * Sample output: The path of ToolkitService.php is: /usr/local/zendsvr6/share/ToolkitApiDev-1.4.0/pre140/ToolkitService.php
	*/
	static function classPath()
	{
		return	__FILE__;
	}  //(static function classPath();
	
	
	/**
	 * given $this->joblog, and an array of program names that might have caused errors,
	 * Extract the error code (CPF or similar) and message text from the joblog.
	 * If can't find error in joblog, uses UNEXPECTED
	 *    and text from $this->XMLWrapper->getLastError();
	 *
	 * Code is placed in $this->cpfErr. Text goes to $this->error.
	 *
	 * @param array $programsToLookFor
	 * @return boolean    True on success, False on failure
	 */
	protected function extractErrorFromJoblog(array $programsToLookFor)
	{
		// CPF, CPC, CPE...
		// also get between
		/*Message . . . . :   Invalid length. MAXLEN for data queue NEWQ in CWDEMO is
		 128.
		Cause . . . . . :  */
	
		// where we can find info in joblog
		$cpfOffset = 0; // first 7 chars is CPF
		$cpfLen = 7;
	
		$pgmOffset = 67; // program name found on same line as CPF code, offset 68
		$pgmLen = 12; // can be special '< lveContext' type names.
	
		$messageLabel = 'Message . . . . :';
		$messageLabelOffset = 37; // "Message . . . . :   "
		$messageLabelLen = strlen($messageLabel);
	
		$causeLabel = 'Cause . . . . . :';
		$recoveryLabel = 'Recovery  . . . :';
	
	
	
		// split on line feeds, then put in reverse order so that we'll get the latest first
		$joblogLines = $lines = preg_split( '/\r\n|\r|\n/', $this->joblog); // split on 0D0A etc.
	
		// in reverse order, look for line with program given/
		// "true" in array_reverse() keeps array index/record numbers intact.
		$startingLine = 0;
		foreach (array_reverse($joblogLines, true) as $lineNum=>$lineString) {
	
			// Look for program name that we originally called.
			// Trim spaces from the right but not the left. (Need pgm name to START in precise location)
			$substringAtProgramLocation = rtrim(substr($lineString, $pgmOffset, $pgmLen));
	
			if (in_array($substringAtProgramLocation, $programsToLookFor)) {
				$startingLine = $lineNum;
				break;
	
			}
		} //(foreach $joblogLines)
	
		if ($startingLine) {
			// we found a joblog entry for the program that we called.
	
			// first line of section has CPF code as well as program name.
			$firstLine = $joblogLines[$startingLine];
	
			// get the error code. We call it CPF but it could also be GUI, CPE, CPC....
			$cpfCode = substr($firstLine, $cpfOffset, $cpfLen);
	
			// go forward till we hit the end or till we come to a new CPF code (detect that if find a fully 7-position string at start)
			$msgText = '';
			$startCollecting = false;
			// get rid of lines before starting line
			$joblogLines = array_slice($joblogLines, $startingLine);
			while (($lineString = next($joblogLines)) && ($lineString !== false) && (strpos($lineString, ' ', $cpfOffset) < $cpfLen)) {
	
				// but start collecting text when we find "Message" label.
				if (substr($lineString, $messageLabelOffset, $messageLabelLen) == $messageLabel) {
					$startCollecting = true;
				}
	
				if ($startCollecting) {
	
					// If not a heading (omit headings)
					/*
					5761SS1 V6R1M0 080215                        Display Job Log                        SBSUSA   11/18/11 15:39:54          Page    2
					Job name . . . . . . . . . . :   QSQSRVR         User  . . . . . . :   QUSER        Number . . . . . . . . . . . :   815166
					Job description  . . . . . . :   QDFTSVR         Library . . . . . :   QGPL
					MSGID      TYPE                    SEV  DATE      TIME             FROM PGM     LIBRARY     INST     TO PGM      LIBRARY     INST
					*/
					$lineLen = strlen($lineString);
	
					// Is a heading if one of the following are found. Use !== false because 0 is a valid "found" result.
					// Check that line length is > 46 before checking for string in position 46, to avoid warning in log
					$isHeadingLine = (($lineLen > 46 && (strpos($lineString, 'Display Job Log', 46) !== false)) ||
							strpos($lineString, 'Job name', 2) !== false ||
							strpos($lineString, 'Job description', 2) !== false ||
							strpos($lineString, 'MSGID', 0) !== false);
	
							if (!$isHeadingLine) {
							    // concatenate whole line. We will remove labels later
							   $msgText .= ' '. trim($lineString);
				            } //(if not a heading line)
	
				} //(if $startCollecting)
	
			} //(while more lines)
	
			/*  Clean up $msgText.
			*  Remove text labels and convert multiple spaces to single space
			*/
			$old = array($messageLabel, $causeLabel, $recoveryLabel, '   ', '  ');
			$new = array('', '', '', ' ', ' ');
			$cleanMsgText = str_replace($old, $new, $msgText);
	
			$this->cpfErr = $cpfCode;
			$this->error = trim($cleanMsgText);
			$this->errorText = trim($cleanMsgText);
	
		} else {
	
		    // could not find it.
		    // use error text from XML parser (though this text is usually worthless)
			$this->cpfErr = 'UNEXPECTED';
			$this->error = $this->XMLWrapper->getLastError();
			$this->errorText = $this->error;
	
	    } //(if $startingLine)
	
	
	    return true;
	    
	} //( function extractErrorFromJoblog)
	
	
	
	/**
	 * changeCurrentUser (1.5.0+) 
	 * Changes the current user of the job to a specific user. All actions will be executed as this user from now on.
	 * Otherwise known as "swap user" or the misnomer "adopt authority."
	 * @param string $user Generally should be uppercase
	 * @param string $password 
	 * @return boolean  True on success, False on failure
	 */
	function changeCurrentUser($user, $password)
	{
		
	    // Force user/pw to uppercase. (should they?)
	    // Ask Support team for opinion on uppercase or not.
		$user = strtoupper($user);
	    $password = strtoupper($password);
	
		// Get profile handle (checking u/p validity)
		// http://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Fapis%2FQSYGETPH.htm
		$apiPgm = 'QSYGETPH';
		$apiLib = 'QSYS';
	
		$pwLen = strlen($password);
		$pwCcsid = '-1'; // -1 means 37 or DFTCCSID depending on password level
	
		$params[] = $this->addParameterChar('in',  10, '1. user',           'user',      $user);
		$params[] = $this->addParameterChar('in',  10, '2. password',       'pw',        $password);
		$params[] = $this->addParameterBin( 'out', 12, '3. profile handle', 'handleOut');
	
		// use a zero (0) bytes length to force errors to bubble up to job. It's easier for us to get full message text from joblog that XMLSERVICE toolkit provides.
		// As well, the QSNDDTAQ API doesn't have an error struct, so this way we can be consistent---get all errors in joblog.
		$params[] = $this->addParameterInt32('both', 'Size of error DS. Use 0 to force errors to bubble up to the job',  'errbytes', '0');
	
		if (substr($password, 0, 1) != '*') {
			/* No asterisk at the start, so this is an attempt at a real password,
			 * not a special pw value starting with an asterisk such as *NOPWD, *NOPWDCHK, or *NOPWDSTS.
			 * Therefore, include pw len and CCSID, which must be omitted if pw is a special "*" value.
			*/
			$params[] = $this->addParameterInt32('both', '5. length of password. Must be equal to the actual pw length.	', 'pwLen',   $pwLen);
			$params[] = $this->addParameterInt32('both', '6. CCSID of password'                                          , 'pwCcsid', $pwCcsid);
	
		} //(if (substr($password, 0, 1) != '*'))
	
		// now call the API, returning results.
		$retPgmArr = $this->PgmCall($apiPgm, $apiLib, $params, null);
	
		if ($this->getErrorMsg() || $this->getErrorCode()) {
			// problem--possibly user or password was wrong
			return false;
		} //(if ($this->getErrorMsg()...)
	
		// get handle from API we called.
		if (isset($retPgmArr['io_param']['handleOut'])) {
			$handle = $retPgmArr['io_param']['handleOut']; // handleOut defined in XML above
		}
	
		// if anything went wrong
		if (!isset($handle) || empty($handle)) {
			return false;
		}
	
		// now set the user profile via the handle.
		// http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=%2Fapis%2FQWTSETP.htm
		$apiPgm = 'QWTSETP'; // set profile
		$apiLib = 'QSYS';
	
		// reset $params array for next API call
		$params = array();
		$params[] = $this->addParameterBin('in', 12, '1. profile handle', 'handleIn', $handle);
		// error ds param
		$params[] = $this->addParameterInt32('both', '2. Size of error DS. Use 0 to force errors to bubble up to the job',  'errbytes', '0');
	
	
		// now call the "set handle" API!
		$retPgmArr = $this->PgmCall($apiPgm, $apiLib, $params);
	
		// any errors?
		if ($this->getErrorMsg() || $this->getErrorCode()) {
			// problem--possibly user or password was wrong
			return false;
		} //(if ($this->getErrorMsg()...)
	
		// Now close/release the handle (handles are limited resources, about 20,000 per job).
		// http://publib.boulder.ibm.com/infocenter/iseries/v7r1m0/index.jsp?topic=%2Fapis%2FQSYRLSPH.htm
		$apiPgm = 'QSYRLSPH'; // release profile handle
		$apiLib = 'QSYS';
	
		// reset $params array for next API call
		$params = array();
		$params[] = $this->addParameterBin('in', 12, '1. profile handle', 'handleIn', $handle);
		// error ds param
		$params[] = $this->addParameterInt32('both', '2. Size of error DS. Use 0 to force errors to bubble up to the job',  'errbytes', '0');
	
		// now call the "release handle" API!
		$retPgmArr = $this->PgmCall($apiPgm, $apiLib, $params);
	
		// any errors?
		if ($this->getErrorMsg() || $this->getErrorCode()) {
			// problem--possibly user or password was wrong
			return false;
		} //(if ($this->getErrorMsg()...)
	
		return true;
	
	} //(function changeCurrentUser)
	

	// return value from toolkit config file,
	// or a default value, or
	// false if not found.
	// method is static so that it can retain its value from call to call.
	static function getConfigValue($heading, $key, $default = null) {
		// TODO store in Zend Data Cache to avoid reading during each request
	
		// if we haven't read config file yet, do so.
		if (!isset(self::$_config)) {
			
			// read/stat INI once and only once per request
			self::$_config = parse_ini_file(CONFIG_FILE, true); // true means use headings
		} //(if (!isset(self::$_config)))
	
		if (isset(self::$_config[$heading][$key])) {
			return self::$_config[$heading][$key];
		} elseif (isset($default)) {
			return $default;
		} else {
			return false;
		}
	
	} //(getConfigValue)

	// get operating system that PHP is running on
	// static method so we don't have to connect to IBM i to find out
	// and to retain value from call to call
	static function getPhpOperatingSystem() {

		if (!isset(self::$_os)) {
			self::$_os = php_uname('s');
		} //(if (!isset(self::$_os)))
		
		return self::$_os;
		
	} //(static function getPhpOperatingSystem())
	
	// return true if PHP is running directly on IBM i, false if not.
	static function isPhpRunningOnIbmI() {
		
		return (self::getPhpOperatingSystem() == 'OS400'); 
		
	} //(static function isPhpRunningOnIbmI())
	
	// return the CCSID of PHP, whether defined in fastcgi or in PASE (php-cli).
	// if none defined then return false.
	static function getPhpCcsid() {
		if (isset($_SERVER['CCSID'])) {
			// web/fastcgi
			return $_SERVER['CCSID'];
		} elseif (isset($_SERVER['QIBM_PASE_CCSID'])) {
			// cli/pase
			return $_SERVER['QIBM_PASE_CCSID'];
		} else {
			return false;
		} //(if (isset($_SERVER['CCSID']))
			
	} //(static function getPhpCcsid())
	
	// TODO these static functions would be better placed in a separate "environment" or utility class than here
	// because they are not concerned with a particular connection.
	
} //(class ToolkitService)

// Class ends above.

// TODO integrate these functions into toolkit class. Back-ported from CW.

// keep non-OO functions for backward compatibility and CW support
function getConfigValue($heading, $key, $default = null)
{
    return ToolkitService::getConfigValue($heading, $key, $default);
    
} //(function getConfigValue())

// non-OO logging function ported from CW
// For CW logging.
function logThis($msg) {
	$logFile = getConfigValue('log','logfile');
	if ($logFile) {
		// it's configured so let's write to it. ("3" means append to a specific file)
		$formattedMsg = "\n" . microDateTime() . ' ' . $msg;
		error_log($formattedMsg, 3, $logFile);
	}

} //(logThis)

function microDateTime()
{
	list($microSec, $timeStamp) = explode(" ", microtime());
	return date('j M Y H:i:', $timeStamp) . (date('s', $timeStamp) + $microSec);
}
