<?php
namespace ToolkitApi;

use PDO;

include_once __DIR__ . DIRECTORY_SEPARATOR . 'ToolkitServiceSet.php';
include_once __DIR__ . DIRECTORY_SEPARATOR . 'ToolkitService.php';

if (!defined('CONFIG_FILE')) {
    define('CONFIG_FILE', 'toolkit.ini');
}


/**
 * Class Toolkit
 *
 * @package ToolkitApi
 */
class Toolkit implements ToolkitInterface
{
    public const VERSION =  "1.9.6"; // version number for front-end PHP toolkit

    /* @todo use inputXml and outputXml to make this class more flexibly OO-like. Fewer strings copied around.
     * Better would be to use a Request object that has a connection.
     * There could be multiple Request objects even if only one connection.
     * Each request object could have its own input and output.
    */
    protected $XMLWrapper = null;
    protected $conn = NULL; // connection to database or other transport

    // @todo create methods to set (separately and all at once) and get errors, akin to what was done for DB module.
    // Test ability to retrieve program errors and text.
    protected $error = ''; // ambiguous usage (it's here for backward compat.) but mainly 7-char error code
    protected $cpfErr = ''; // 7-char error code
    protected $errorText = ''; // error text/msg

    // $db2 variable may not be needed. Consider deprecating in future.
    protected $db2 = false;

    /**
     * @var null|resource|PDO|PdoSupp|odbcsupp|db2supp
     */
    protected $db = null; // contains class for db connections

    protected $_i5NamingFlag = 0; // same as DB2_I5_NAMING_OFF; // Other value could be 1 (DB2_I5_NAMING_ON).
    protected $_schemaSep = '.'; // schema separator. A dot or slash
    protected $_validSeparators = array('.', '/');

    protected $_outputVarsToExport = array();
    protected $_isPersistent = false;

    protected $_transport;

    protected $_isCw = false; // whether the CW is used for this instance.

    protected static $_config; // config options from INI file. Accessed by static method getConfigValue();
    protected static $_os; // operating system

    // brought over from CW
    protected $joblog = '';
    protected $_privateConnNum = null;
    protected $_isNewConn = true; // default to "new/true" because it's safest. new means app perhaps should initalize job.
    // In case of error, look for CPFs generated by specific other programs.
    // E.g. if userid is wrong when calling QSYGETPH, the CPF may be reported by program QSYPHDL in joblog.
    // @todo would be better specified in external file or in INI.
    protected $_cpfMapping = array('QSYRUSRI' => array('QLIROHDL'), 'QSYGETPH' => array('QSYPHDL'));

    // options that can be set at any time
    // Set them with setOptions or setToolkitServiceParams
    // Get them with getOption or getToolkitServiceParam
    protected $_options = array('plug'           => 'iPLUG512K', //for ibm_db2. for odbc $plug='iPLUGR512K'. consider 4K with small data
                                'plugSize'       => '512K', // 4K, 32K, 512K, 65K, 512K, 1M, 5M, 10M, 15M
                                'plugPrefix'     => 'iPLUG', // iPLUG (ibm_db2) or iPLUGR (odbc)
                                'XMLServiceLib'  => XMLSERVICELIB, // library containing XMLSERVICE
                                'HelperLib'      => ZSTOOLKITLIB, // library containing Zend Server's RPG service program (ZSXMLSRV by default) that handles some of the toolkit's duties.
                                'v5r4'           => false, // whether to ask XMLSERVICE to carefully use features that v5r4 can handle
                                'sbmjobParams'   => '', // XMLSERVICE itself will provide good defaults in most cases (in production ZENDSVR(6)/ZSVR_JOBD/XTOOLKIT. In test mode, QSYS/QSRVJOB/XTOOLKIT). See PLUGCONF1 and 2
                                'debug'          => false,
                                'debugLogFile'   => '/usr/local/zendsvr6/var/log/debug.log',
                             // CCSID/Hex at a global/request level. These properties are also defined at a parameter object level.
                                'ccsidBefore'    => '',
                                'ccsidAfter'     => '',
                                'useHex'         => false,
                                'paseCcsid'      => '', // PASE CCSID for <sh> pase such as WRKACTJOB
                                'trace'          => false, // whether to enable XMLSERVICE internal log
                                'sbmjobCommand'  => '', // optional complete override of SBMJOB command when new toolkit job is submitted
                                'prestart'       => false,
                                'stateless'      => false,
                                'performance'    => false, // whether to enable performance collection (not fully implemented)
                                'idleTimeout'    => '', // created for Compat. Wrapper (CW)
                                'cdata'          => true, // whether to ask XMLSERVICE to wrap its output in CDATA to protect reserved XML characters
                                'internalKey'    => XMLINTERNALKEY, // consistent naming style
                                'encoding'       => "ISO-8859-1", /*English. Hebrew:ISO-8859-8 */
                                'schemaSep'      => '.', // schema separator. A dot or slash
                                'parseOnly'      => false, // do not run any program; simply parse, expand dim if necessary, and return.
                                'parseDebugLevel' => 1, // 1-9 debug level when in parseOnly mode
                                'license'        => false, // true to receive license/version information
                                'transport'      => false, // check proc call speed (no XML calls)
                                'dataStructureIntegrity' => false, // New in 1.4.0. Specify true to preserve integrity of data structures. If false (default), explode inner values out of the ds.
                                'arrayIntegrity' => false, // New in 1.4.0. Specify true to preserve integrity of arrays (to create true named arrays, not merely sequentially numbered elements).
                                'customControl'  => '', // any string you want. Will be concatenated to control key string after a single space.
                                'transportType'  => 'ibm_db2', // can override in getInstance constructor as well
                                'httpTransportUrl' => '', // for HTTP REST transport
                                'timeReport'      => false, // *fly or *nofly; if true, return tick counts instead of data.
                                'xmlserviceCliPath' => '/QOpenSys/pkgs/bin/xmlservice-cli', // The path to the xmlservice-cli program (or compatible API) on the IBM i system. The full path should be used because $PATH may not be set up.
    );

    // plug size to bytes cross-reference
    protected $_dataSize = array("4K"   => 4096,
                                 "32K"  => 32000,
                                 "65K"  => 65000,
                                 "512K" => 512000,
                                 "1M"   => 1000000,
                                 "5M"   => 5000000,
                                 "10M"  => 10000000,
                                 "15M"  => 15000000);

    protected $serviceParams;
    protected $optionalParamNames;
    protected $execStartTime;


    /**
     * Return true if we are in debug mode
     * Return false if not
     *
     * Usage:
     * $isDebug= $this->isDebug();
     *
     * @return boolean
     */
    protected function isDebug()
    {
        return $this->getOption('debug');
    }

    /**
     * if passing an existing resource and naming, don't need the other params.
     *
     * @param string|resource|PDO|Odbc\Connection $databaseNameOrResource
     * @param string $userOrI5NamingFlag 0 = DB2_I5_NAMING_OFF or 1 = DB2_I5_NAMING_ON
     * @param string $password
     * @param string $transportType (http, ibm_db2, odbc, ssh, local)
     * @param array|bool $options Connection options. bool is for just isPersistent (compatibility)
     * @throws \Exception
     */
    public function __construct($databaseNameOrResource, $userOrI5NamingFlag = '0', $password = '', $transportType = '', $options = array("isPersistent" => false))
    {
        $this->execStartTime = '';
        // to avoid having to rewrite the other code paths
        $isPersistent = false;
        if (is_bool($options)) {
            // compatibility with legacy isPersistent
            $isPersistent = $options;
            $options = array("isPersistent" => $options);
        } else if (is_array($options)) {
            $isPersistent = array_key_exists("isPersistent", $options) ? $options["isPersistent"] : false;
        }

        // stop any types that are not valid for first parameter. Invalid values may cause toolkit to try to create another database connection.
        if (!is_string($databaseNameOrResource) && !is_resource($databaseNameOrResource) && ((!is_object($databaseNameOrResource) || (is_object($databaseNameOrResource) && !in_array(get_class($databaseNameOrResource), [PDO::class, \Odbc\Connection::class, \Pdo\Odbc::class], true))))) {

            // initialize generic message
            $this->error = "\nFailed to connect. databaseNameOrResource " . var_export($databaseNameOrResource, true) . " not valid.";

            // change to a more specific helpful message if a boolean false arising from a failed database connection passed in
            if (false === $databaseNameOrResource) {
                $this->error = "\nFailed to connect. If you passed in a database connection, it was a failed one with a value of false.";
            }

            $this->debugLog($this->error);
            throw new \Exception($this->error);

        } // (if (!is_string....)

        // set service parameters to use in object.
        $this->serviceParams = $this->getDefaultServiceParams();

        if ($this->getConfigValue('system', 'sbmjob_params')) {
            $this->serviceParams['sbmjobParams'] = $this->getConfigValue('system', 'sbmjob_params');
        }

        // Optional params. Don't specify if not given in INI.
        $this->getOptionalParams('system', array('v5r4', 'ccsidBefore', 'ccsidAfter', 'useHex', 'paseCcsid', 'trace', 'dataStructureIntegrity',  'arrayIntegrity'));
        $this->getOptionalParams('transport', array('httpTransportUrl', 'plugSize', 'xmlserviceCliPath'));

        // populate serviceParams with $transport, or get it from INI
        if (!$transportType) {
            $this->getOptionalParams('transport', array('transportType'));
        } else {
            $this->serviceParams['transportType'] = $transportType;
        }

        // set up options in this object. Includes debugging, logging, transport.
        $this->setOptions($this->serviceParams);

        // get transport type from options, wherever it came from, and lowercase it.
        $transportType = $this->getOption('transportType');
        if (is_string($transportType)) {
            $transportType = strtolower($transportType);
        }
        
        $isResource = is_resource($databaseNameOrResource);
        $isPdo = ($databaseNameOrResource instanceof PDO);
        
        if ($this->isDebug()) {
            
            if ($isPdo) {
                $databaseString = 'PDO driver: ' . $databaseNameOrResource->getAttribute(PDO::ATTR_DRIVER_NAME) . '. Object hash: ' . spl_object_hash($databaseNameOrResource);
            } else {
                $databaseString = $databaseNameOrResource;
            } //(if ($isPdo))
            
            $this->debugLog("Creating new toolkit conn with database: '$databaseString', user or i5 naming flag: '$userOrI5NamingFlag', transport: '$transportType', persistence: '$isPersistent'\n");
        } //(if ($this->isDebug()))
        
        // do we have a DB resource "by user" or do we create one
        if ($transportType === 'ibm_db2' && $isResource) {
            $conn = $databaseNameOrResource;
            $this->_i5NamingFlag = $userOrI5NamingFlag;
            $schemaSep = ($this->_i5NamingFlag) ? '/' : '.';
            $this->setOptions(array('schemaSep' => $schemaSep));
            $this->chooseTransport('ibm_db2');
            if ($this->isDebug()) {
                $this->debugLog("Re-using existing db connection with schema separator: $schemaSep");
            }
        } elseif ($transportType === 'odbc' && ($isResource || $databaseNameOrResource instanceof \Odbc\Connection)) {
            $conn = $databaseNameOrResource;
            $this->_i5NamingFlag = $userOrI5NamingFlag;
            $schemaSep = ($this->_i5NamingFlag) ? '/' : '.';
            $this->setOptions(array('schemaSep' => $schemaSep));
            $this->chooseTransport('odbc');
            if ($this->isDebug()) {
                $this->debugLog("Re-using existing db connection with schema separator: $schemaSep");
            }
        } elseif ($transportType === 'pdo' && $isPdo) {
            $conn = $databaseNameOrResource;
            $this->db = $conn;
            $this->_i5NamingFlag = $userOrI5NamingFlag;
            $schemaSep = ($this->_i5NamingFlag) ? '/' : '.';
            $this->setOptions(array('schemaSep' => $schemaSep));
            $this->chooseTransport('pdo');
            if ($this->isDebug()) {
                $this->debugLog("Re-using existing db connection with schema separator: $schemaSep");
            }
        } elseif ($transportType === 'local') {
            $user = $userOrI5NamingFlag;
            $this->chooseTransport($transportType);
            $transport = $this->getTransport();
            // Doesn't actually do any connecting, but does validate
            $conn = $transport->connect($databaseNameOrResource, $user, $password, $options);
        } elseif ($transportType === 'ssh') {
            $user = $userOrI5NamingFlag;
            $this->chooseTransport($transportType);
            $transport = $this->getTransport();
            if (is_resource($databaseNameOrResource)) {
                $sshConn = $databaseNameOrResource;
                $conn = $transport->connectWithExistingConnection($sshConn);
            } else {
                $serverName = $databaseNameOrResource;
                $conn = $transport->connect($serverName, $user, $password, $options);
            }
        } elseif ($transportType === 'http' || $transportType === 'https') {
            $databaseName = $databaseNameOrResource;
            $user = $userOrI5NamingFlag;
            $this->chooseTransport($transportType);
            $transport = $this->getTransport();
            $conn = $transport->connect($databaseName, $user, $password, array('persistent'=>$this->getIsPersistent()));
        } else {
            $databaseName = $databaseNameOrResource;
            $user = $userOrI5NamingFlag;

            if ($this->isDebug()) {
                $this->debugLog("Creating a new db connection at " . date("Y-m-d H:i:s") . ".\n");
                $this->execStartTime = microtime(true);
            }

            $this->setIsPersistent($isPersistent);
            $this->chooseTransport($transportType);
            $transport = $this->getTransport();
            $conn = $transport->connect($databaseName, $user, $password, array('persistent'=>$this->getIsPersistent()));

            if ($this->isDebug()) {
                $durationCreate = sprintf('%f', microtime(true) - $this->execStartTime);
                $this->debugLog("Created a new db connection in $durationCreate seconds.");
            }

            // Just check if the transport connection isn't false/null.
            // Stricter checks for resource vs. object should be done at
            // transport level due to version variance.
            if (!$conn) {
                // Note: SQLState 08001 (with or without SQLCODE=-30082) usually means invalid user or password. This is true for DB2 and ODBC.
                $sqlState = $transport->getErrorCode();
                $this->error = $transport->getErrorMsg();

                $this->debugLog("\nFailed to connect. sqlState: $sqlState. error: $this->error");
                throw new \Exception($this->error, (int)$sqlState);
            }
        }

        $this->conn = $conn;
    }

    /**
     * @throws \Exception
     */
    public function __clone()
    {
        throw new \Exception(" Use getInstance() function according to create a new ToolkitService object");
    }

    /**
     * get service param values from Config to use in object
     *
     */
    protected function getDefaultServiceParams()
    {
        return array('XMLServiceLib'     => $this->getConfigValue('system', 'XMLServiceLib', 'ZENDSVR6'),
            'HelperLib'         => $this->getConfigValue('system', 'HelperLib', 'ZENDSVR6'),
            'debug'             => $this->getConfigValue('system', 'debug', false),
            'debugLogFile'      => $this->getConfigValue('system', 'debugLogFile', false),
            'encoding'          => $this->getConfigValue('system', 'encoding', 'ISO-8859-1'),
            'parseOnly'         => $this->getConfigValue('testing', 'parse_only', false),
            'parseDebugLevel'   => $this->getConfigValue('testing', 'parse_debug_level', null));
    }

    /**
     * get optional param values from Config and add them to the service params
     *
     * @param $type
     * @param array $optionalParams
     */
    protected function getOptionalParams($type, array $optionalParams)
    {
        foreach ($optionalParams as $optionalParamName) {
            $val = $this->getConfigValue($type, $optionalParamName);

            if ($val) {
                $this->serviceParams[$optionalParamName] = $val;
            }

            $this->optionalParamNames = $optionalParamName;
        }
    }

    /**
     * whether we're using CW (compatibility wrapper) or not
     *
     * @param $isCw
     */
    public function setIsCw($isCw)
    {
        $this->_isCw = $isCw;
    }

    /**
     * @return bool
     */
    public function getIsCw()
    {
        return $this->_isCw;
    }

    /**
     * return array of valid plug sizes.
     * public method in case an application wishes to validate.
     *
     * @return array
     */
    public function validPlugSizes()
    {
        return array_keys($this->_dataSize);
    }

    /**
     * valid plug sizes separated by commas. Useful for informational messages.
     *
     * @return string
     */
    protected function validPlugSizeList()
    {
        return implode(', ', $this->validPlugSizes());
    }

    /**
     * return size in bytes based on plugSize.
     *
     * @param $plugSize
     * @throws \Exception
     */
    protected function plugSizeToBytes($plugSize)
    {
        // return size in bytes based on plugSize.
        if (isset($this->_dataSize[$plugSize])) {
            return $this->_dataSize[$plugSize];
        }

        throw new \Exception("plugSize '$plugSize' is not valid. Try one of these: " . $this->validPlugSizeList());
    }

    /**
     * @param $transportObject
     */
    protected function setTransport($transportObject)
    {
        $this->_transport = $transportObject;
    }

    /**
     * @return mixed
     */
    protected function getTransport()
    {
        return $this->_transport;
    }

    /**
     * Choose data transport type: ibm_db2, odbc, pdo, http, https, ssh, local
     *
     * @param string $transportName 'ibm_db2' or 'odbc' or 'pdo' or 'http' or 'https' or 'ssh' or 'local'
     * @throws \Exception
     */
    protected function chooseTransport($transportName = '')
    {
        switch($transportName)
        {
            case 'local':
                $transport = new LocalSupp();
                $transport->setXmlserviceCliPath(
                    $this->getOption('xmlserviceCliPath')
                );
                $this->setTransport($transport);
                break;
            case 'ssh':
                $transport = new SshSupp();
                $transport->setXmlserviceCliPath(
                    $this->getOption('xmlserviceCliPath')
                );
                $this->setTransport($transport);
                break;
            case 'http':
                $transport = new httpsupp();
                $transport->setUrl(
                    $this->getOption('httpTransportUrl')
                );
                $this->setTransport($transport);
                break;
            case 'https':
                $transport = new httpsupp();

                // Set SSL certificate authority file
                $sslCaFile = $this->getConfigValue('transport', 'sslCaFile');
                $transport->setSSLCAFile($sslCaFile);

                // Set server name
                $serverName = $this->getConfigValue('transport', 'serverName');
                $transport->setServerName($serverName);
                $transport->setUrl(
                    $this->getOption('httpTransportUrl')
                );
                $this->setTransport($transport);
                break;
            default:
                $this->setDb($transportName);
        }
    }

    /**
     * transport type is same as db extension name when a db transport is used.
     *
     * @param string $transportType
     * @throws \Exception
     */
    protected function setDb($transportType = '')
    {
        $transportType = trim($transportType);

        // if extension is specified, use it; else use default db.
        $extensionName = ($transportType) ? $transportType : DBPROTOCOL;

        if (!extension_loaded($extensionName)) {
            throw new \Exception("Extension $extensionName not loaded.");
        }

        // extension is loaded. Set up db transport objects.

        if ($extensionName === 'ibm_db2') {
                $this->setOptions(array('plugPrefix' => 'iPLUG'));
                $this->db = new db2supp();

                $this->setDb2(); // not used in toolkit anymore but keep for backwards compat.
        } elseif ($extensionName === 'odbc') {
                //for odbc will be different default stored procedure call
                $this->setOptions(array('plugPrefix' => 'iPLUGR')); // "R" = "result set" which is how ODBC driver returns param results
                $this->db = new odbcsupp();
        } elseif ($extensionName === 'pdo') {
            $this->setOptions(array('plugPrefix' => 'iPLUGR'));
            $this->db = new PdoSupp($this->db);
        }

        // transport, too, to be generic
        $this->setTransport($this->db);

        return;
    }

    /**
     * Also alias setOptions()
     *
     * @param array $XmlServiceOptions
     */
    public function setToolkitServiceParams(array $XmlServiceOptions)
    {
        // copy incoming options to new array that we can safely manipulate
        $options = $XmlServiceOptions;

        // special cases first

        /* If sbmjobParams is present, it must contain at least one slash. If not, do not process it.
        *  The slash implies that subsystem name and subsytem decscription (and, optionally, job name)
        *  are present in the string
        */
        if (isset($options['sbmjobParams']) && !strstr($options['sbmjobParams'], "/")) {
            unset($options['sbmjobParams']);
        } //(if sbmjobParams is set but no slash)


        // if a plug name is passed in, it overrides plugPrefix and plugSize.
        if (isset($options['plug']) && $options['plug']) {
            // @todo enumerate plug prefixes centrally, tied to db extension name, at top of this class
            $possiblePrefixes = array('iPLUGR', 'iPLUG');
            $options['plugSize'] = str_replace($possiblePrefixes, '', $options['plug']); // remove prefix to get size
            $options['plugPrefix'] = str_replace($options['plugSize'], '', $options['plug']); // remove size to get prefix

        }

        // encoding provided but it's blank
        if (isset($options['encoding']) && !$options['encoding']) {
            unset($options['encoding']);
        }

        // verify that schemaSep is a valid character for this purpose
        if (isset($options['schemaSep']) && !in_array($options['schemaSep'], $this->_validSeparators)) {
            unset($options['schemaSep']);
        }

        // handle case sensitivity. Put value in index of proper camel casing
        if (isset($options['InternalKey'])) {
            $options['internalKey'] = $options['InternalKey'];
        }

        // now set all in a generic fashion
        // loop through all options provided in param
        foreach ($options as $optionName=>$optionValue) {

            if (isset($this->_options[$optionName])) {
                // it's valid. Set class property to its value.
                $this->_options[$optionName] = $optionValue;
            }
        }
    }

    /**
     * shorthand for getToolkitServiceParam()
     *
     * @param $optionName
     * @return bool|void
     * @throws \Exception
     */
    public function getOption($optionName)
    {
        $result = $this->getToolkitServiceParam($optionName);

        if ($result) {
            return $result;
        }

        return false;
    }

    /**
     * retrieve full toolkit option array
     *
     * @return array
     */
    public function getOptions()
    {
        return $this->_options;
    }

    /**
     * shorthand for setToolkitServiceParams()
     *
     * @param array $options
     */
    public function setOptions($options = array())
    {
        $this->setToolkitServiceParams($options);
    }

    /**
     * get a single option value
     * return property value if property is set.
     *
     * @param $optionName
     * @return bool
     * @throws \Exception
     */
    public function getToolkitServiceParam($optionName)
    {
        // special case, case sensitivity
        if ($optionName == 'InternalKey') {
            $optionName = 'internalKey';
        }

        // we use array_key_exists() rather than isset() because the value may be null.
        if (array_key_exists($optionName, $this->_options)) {
            return $this->_options[$optionName];
        } else {
            // nothing matched
            Throw new \Exception("Invalid option requested: $optionName");
        }
    }

    /**
     * end job if private job (internal key set); end DB transport if not persistent.
     */
    public function disconnect()
    {
        // if stateful connection, end the toolkit job.
        if (!$this->isStateless()) {
            $this->PgmCall("OFF", NULL);
        }

        // if transport is a db, end the db connection.
        if (isset($this->db) && $this->db) {
            $this->db->disconnect($this->conn);
        }

        $this->conn = null;
    }

    /**
     * same as disconnect but also really close persistent database connection.
     */
    public function disconnectPersistent()
    {
        $this->PgmCall("OFF", NULL);

        if (isset($this->db) && $this->db) {
            $this->db->disconnectPersistent($this->conn);
        }
        $this->conn = null;
    }

    /**
     * @param $stringToLog
     */
    public function debugLog($stringToLog)
    {
        if ($this->isDebug()) {
            error_log("$stringToLog", 3, $this->getOption('debugLogFile'));
        }
    }

    /**
     * isDb2 and setDb2 may not be needed. Deprecate in future.
     *
     * @return bool
     */
    public function isDb2()
    {
       return $this->db2;
    }

    /**
     * @return bool
     */
    public function setDb2()
    {
       return $this->db2 = true;
    }

    /**
     * for special requests such as transport, performance, license
     *
     * @param $callType
     * @return array|bool
     */
    public function specialCall($callType)
    {
        $this->setOptions(array($callType=>true));
        $outputArray = $this->PgmCall("NONE", NULL, NULL ,NULL);
        $this->setOptions(array($callType=>false));

        return $outputArray;
    }

    /**
     * @return array|bool
     */
    public function callTransportOnly()
    {
        return $this->specialCall('transport');
    }

    /**
     * @return array|bool
     */
    public function performanceData()
    {
        return $this->specialCall('performance');
    }

    /**
     * return license/version information
     *
     * @return array|bool
     */
    public function licenseXMLSERVICE()
    {
        return $this->specialCall('license');
    }

    /**
     * pgmCall
     *
     * @param string $pgmName Name of program to call, without library
     * @param string $lib Library of program. Leave blank to use library list or current library
     * @param mixed[]|null $inputParam An array of ProgramParameter objects OR XML representing params, to be sent as-is.
     * @param mixed[]|null $returnParam ReturnValue Array of one parameter that's the return value parameter
     * @param mixed[]|null $options Array of other options. The most popular is 'func' indicating the name of a subprocedure or function.
     * @return array|bool
     */
    public function pgmCall($pgmName, $lib, $inputParam = NULL, $returnParam = NULL, $options = NULL)
    {
        $this->cpfErr = '';
        $this->error = '';
        $this->joblog = '';
        $function = NULL;

        ProgramParameter::initializeFallbackVarName();

        // If only one 'return' param, turn it into an array for later processing.
        if ($returnParam instanceof ProgramParameter) {
            $returnParam = array($returnParam);
        }

        $this->XMLWrapper = new XMLWrapper(array('encoding' => $this->getOption('encoding')), $this);

        // $optional handles special requests such as 'license'
        $disconnect = (strcmp($pgmName, "OFF") === 0) ? true : false;
        $optional = (strcmp($pgmName, "NONE") === 0) ? true : false;

        $outputParamArray = false;

        if (isset($options['func'])) {
            $function = $options['func'];
        }

        if ($disconnect || $optional) {
            $inputXml = $this->XMLWrapper->disconnectXMLIn();
        } else {
            $inputXml = $this->XMLWrapper->buildXmlIn($inputParam, $returnParam, $pgmName, $lib, $function);
        }

        // send XML to XMLSERVICE
        $outputXml = $this->sendXml($inputXml, $disconnect);

        if ($outputXml != '') {

            $outputParamArray = $this->XMLWrapper->getParamsFromXml($outputXml);

            // didn't get expected return, search logs to find out why
            if (!is_array($outputParamArray)) {
                // No real data. Look for errors. Retrieve details from joblog.
                $this->joblog = $this->XMLWrapper->getLastJoblog();

                // standard list of programs that provide CPF codes in joblog
                $programsToLookFor = array($pgmName, '< lveContext', '#mnrnrl', 'QRNXIE', '< allProgram');

                if (isset($this->_cpfMapping[$pgmName])) {
                    // list of other programs not called directly that might generate CPF codes in joblog.
                    $programsToLookFor = array_merge($programsToLookFor, $this->_cpfMapping[$pgmName]);
                }

                // put values in $this->cpfErr and $this->error
                $this->extractErrorFromJoblog($programsToLookFor);
            }
         }

         unset ($this->XMLWrapper);

         // output array includes in/out parameters and return parameters.
         return $outputParamArray;
    }

    /**
     * help people accustomed to outputting a resource as string and for testing
     *
     * @return string
     */
    public function __toString()
    {
        $ipc = trim($this->getInternalKey());
        $serviceLibrary = $this->getOption('XMLServiceLib');
        $stringStart = "ToolkitService object using service library $serviceLibrary.";
        $ipcInfo = ($ipc) ? "Internalkey: '$ipc'" : "Running stateless (inline, no IPC).";

        return "$stringStart $ipcInfo";
    }

    /**
     * @return string
     */
    public function getErrorMsg() {
        return $this->errorText;
    }

    /**
     * @return string
     */
    public function getErrorCode()
    {
        return $this->cpfErr;
    }

    /**
     * @param $msg
     */
    public function setErrorMsg($msg)
    {
        $this->errorText = $msg;
    }

    /**
     * @param $code
     */
    public function setErrorCode($code)
    {
        $this->cpfErr = $code;
    }

    /**
     * @param array $OutputArray
     * @return bool
     */
    public function getOutputParam(array $OutputArray)
    {
        if (!is_array($OutputArray)) {
            return false;
        }

        if (isset($OutputArray['io_param'])) {
            return $OutputArray['io_param'];
        }

        return false;
    }

    /**
     * Send any XML to XMLSERVICE toolkit. The XML doesn't have to represent a program.
     * Was protected; made public to be usable by applications.
     *
     * @param $inputXml
     * @param bool $disconnect
     * @return string
     * @throws \Exception
     */
    public function ExecuteProgram($inputXml, $disconnect = false)
    {
        $this->execStartTime = '';
        $this->error = '';

        $this->VerifyPLUGName(); // calculates value of option 'plug'
        $this->VerifyInternalKey();

        // @todo create driver-specific SQL in driver classes (db2, odbc)
        $internalKey = $this->getInternalKey();
        $controlKeyString = $this->getControlKey($disconnect);

        $plugSize = $this->getOption('plugSize');

        // @todo have one transport class that includes db as well.

        // If a database transport
        if (isset($this->db) && $this->db) {
            $result = $this->makeDbCall($internalKey, $plugSize, $controlKeyString, $inputXml, $disconnect);
        } else if ($this->getTransport() instanceof LocalSupp) {
            // Not divergent from SSH impl just yet
            $transport = $this->getTransport();
            $xmlserviceCliPath = $this->getOption('xmlserviceCliPath');
            $transport->setXmlserviceCliPath($xmlserviceCliPath);

            // if debug mode, log control key, and input XML.
            if ($this->isDebug()) {
                // Local transport doesn't use IPC/CTL/out sizes, don't mention them
                $this->debugLog("\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() ."\nToolkit class: '" . __FILE__ . "'\nInput XML: $inputXml\n");
                $this->execStartTime = microtime(true);
            }

            $result = $transport->send($inputXml);
        } else if ($this->getTransport() instanceof SshSupp) {
            $transport = $this->getTransport();
            $xmlserviceCliPath = $this->getOption('xmlserviceCliPath');
            $transport->setXmlserviceCliPath($xmlserviceCliPath);

            // if debug mode, log control key, and input XML.
            if ($this->isDebug()) {
                // SSH transport doesn't use IPC/CTL/out sizes, don't mention them
                $this->debugLog("\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() ."\nToolkit class: '" . __FILE__ . "'\nInput XML: $inputXml\n");
                $this->execStartTime = microtime(true);
            }

            $result = $transport->send($inputXml);
        } else if ($this->getTransport() instanceof httpsupp) {
            $transport = $this->getTransport();
            $transport->setIpc($internalKey);
            $transport->setCtl($controlKeyString);
            $url = $this->getOption('httpTransportUrl');
            $transport->setUrl($url);

            // convert plugSize to bytes
            $outByteSize = $this->plugSizeToBytes($plugSize);

            // if debug mode, log control key, and input XML.
            if ($this->isDebug()) {
                $this->debugLog("\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() ."\nToolkit class: '" . __FILE__ . "'\nIPC: '" . $this->getInternalKey() . "'. Control key: $controlKeyString\nHost URL: $url\nExpected output size (plugSize): $plugSize or $outByteSize bytes\nInput XML: $inputXml\n");
                $this->execStartTime = microtime(true);
            }

            $result = $transport->send($inputXml, $outByteSize);
        }

        // workaround: XMLSERVICE as of 1.7.4 returns a single space instead of empty string when no content was requested.
        $result = trim($result);

        if ($this->isDebug() && $result) {
            $end = microtime(true);
            $elapsed = $end - $this->execStartTime;
            $this->debugLog("Output XML: $result\nExec end: " . date("Y-m-d H:i:s") . ". Seconds to execute: $elapsed.\n\n");
        }

        return $result;
    }

    /**
     * @param string $internalKey
     * @param string $plugSize
     * @param string $controlKeyString
     * @param string $inputXml
     * @param bool $disconnect
     * @return string
     */
    protected function makeDbCall($internalKey, $plugSize, $controlKeyString, $inputXml, $disconnect = false)
    {
        $toolkitLib = $this->getOption('XMLServiceLib');
        $schemaSep = $this->getOption('schemaSep');
        $transportType = $this->getOption('transportType');

        $plugPrefix =  $this->getOption('plugPrefix');
        // construct plug name from prefix + size
        $plug = $plugPrefix . $plugSize; // e.g. iPLUG512K

        if ($plugPrefix == 'iPLUG') {
            // db2 driver stored procedures take 4 params
            $sql =  "call {$toolkitLib}{$schemaSep}{$plug}(?,?,?,?)";
        } else {    /*odbc, iPLUGR */
            // only three params for odbc stored procedures
            $sql =  "call {$toolkitLib}{$schemaSep}{$plug}(?,?,?)";
        }

        $bindArray = array(
            'internalKey' => $internalKey,
            'controlKey' => $controlKeyString,
            'inputXml' => $inputXml,
            'outputXml' => '',
            'disconnect' => $disconnect
        );

        // if debug mode, log control key, stored procedure statement, and input XML.
        if ($this->isDebug()) {
            $this->debugLog("\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() ."\nIPC: '" . $this->getInternalKey() . "'. Control key: $controlKeyString\nStmt: $sql with transport: $transportType\nInput XML: $inputXml\n");
            $this->execStartTime = microtime(true);
        }

        // can return false if prepare or exec failed.
        $outputXml = $this->db->execXMLStoredProcedure($this->conn, $sql, $bindArray);
        if (false === $outputXml) {
            // if false returned, was a database error (stored proc prepare or execute error)
            // @todo add ODBC SQL State codes

            // If can't find stored proc for ODBC: Database code (if any): S1000. Message: [unixODBC][IBM][System i Access ODBC Driver][DB2 for i5/OS]SQL0440 - Routine IPLUG512K in XMLSERVICE not found with specified parameters.
            //Warning: odbc_prepare(): SQL error: [unixODBC][IBM][System i Access ODBC Driver][DB2 for i5/OS]SQL0440 - Routine IPLUG512K in XMLSERVICE not found with specified parameters., SQL state S1000 in SQLPrepare in /usr/local/zend/ToolkitAPI/Odbcsupp.php on line 89
            $this->cpfErr = $this->db->getErrorCode();
            $this->setErrorMsg($this->db->getErrorMsg());

            $errorReason = $this->getErrorReason($plugSize);

            logThis($errorReason);
            die($errorReason);
        }

        if ($disconnect) {
            $this->db->disconnect($this->conn);

            if ($this->isDebug()) {
                $this->debugLog("Db disconnect requested and done.\n");
            } //(debug)
        }

        return $outputXml;
    }

    protected function getErrorReason($plugSize)
    {
        $serviceLibrary = $this->getOption('XMLServiceLib');

        if ($this->cpfErr == 22001) {
            //22001 = On db2_execute, plug was too small to get input XML.
            $errorReason = "Error: XML input was too large for the current plug size, '$plugSize'. Set a larger plugSize.";
        } elseif ($this->cpfErr == 22003) {
            //22003 = On db2_execute, plug was too small to get output XML.
            $errorReason = "Error: XML output was too large for the current plug size, '$plugSize'. Set a larger plugSize.";
        } elseif ($this->cpfErr == 22501) {
            //22501 = Probably missing the LOB DB2 PTF. Get the latest DB2 Group PTF or CUME.
            // or individual PTF:
            //        V5R4: 5722SS1 SI39610
            //         6.1: 5761SS1 SI39829
            //         7.1: 5770SS1 SI39831/SI39917
            $errorReason = "Error: http://forums.zend.com/viewtopic.php?f=113&t=45413 Message: {$this->error}.";
        } elseif ($this->cpfErr == 38501) {
            // SQLState 38501: error in stored procedure. Possibly trace=true but library XMLSERVLOG doesn't exist.
            //          or     Trigger program or external routine detected an error. SQLCODE=-443
            $errorReason = "Error: SQLState 38501. Message: {$this->error}. Error in stored procedure or program. Could be a library that does not exist. If trace=true (not debug--trace), make sure XMLSERVLOG exists.";
        } elseif ($this->cpfErr == 42704) {
            //42704 = obj not found
            $errorReason = "Error: Toolkit not found in specified service library ($serviceLibrary).";
        } elseif ($this->cpfErr == 42833) {
            //42833 = The qualified object name is inconsistent with the naming option.
            $errorReason = "Error: i5_naming mismatch. When connecting to the toolkit, you specified i5_naming='$this->_i5NamingFlag' (or left the default of 0), which does not match the naming mode of the database job. Solution: If you are using a persistent database connection, ensure that every time you connect to db2 or the toolkit with a given user profile, you specify the same naming value for 'i5_naming'. If you are using library lists or a schema separator of '/', the naming mode must be '1'.";
        } elseif ($this->cpfErr == 58004) {
            //58004 = The qualified object name is inconsistent with the naming option.
            $errorReason = "Error:  Message: {$this->error}. SQLState 58004. If SQLCode is -901, check previous messages in joblog. Could mean an incorrect library in library list or another previous error in database job.";
        } elseif ($this->cpfErr == '' || $this->cpfErr == 'HY017') {
            // no SQLSTATE or HY017: The DB2 QSQSRVR job no longer exists.
            $errorReason = "Error: SQLSTATE='{$this->cpfErr}' and Message: '{$this->error}', indicating that this PHP job's associated database job is no longer running.";
        } else {
            $errorReason = "Toolkit request failed. Review the database code and message.";
            $errorReason .= " Database code (if any): '{$this->cpfErr}'. Message: {$this->error}";
        }

        // other codes: SQLState 38501: error in stored procedure. Possibly trace=true but library XMLSERVLOG doesn't exist.
        //                       38501: Trigger program or external routine detected an error. SQLCODE=-443
        //                              could be bad library in libl.
        //    in joblog, see:
        /* CPF2110  Library GLUMP not found.
         * then:
         * SQL0443 Message . . . . :   Trigger program or external routine detected an error.

        Cause . . . . . :   Either a trigger program, external procedure, or external
          function detected and returned an error to SQL. If the error occurred in a
          trigger program, the trigger was on table QCMDEXC in schema QSYS. If the
          error occurred in an external procedure or function, the external name is
          QCMDEXC in schema QSYS.  The associated text is Library GLUMP not found..
          If the error occurred in a trigger program, the associated text is the type
          of trigger program.  If the error occurred in an external function, the
          associated text is the text of the error message returned from the external
          function.
         */

        return $errorReason;
    }

    /**
     * Alias of ExecuteProgram();
     * Send any XML to XMLSERVICE toolkit. The XML doesn't have to represent a program.
     *
     * @todo create method to parse XML appropriately no matter what type of tags (cmd/pgm etc.)
     *
     * @param $inputXml
     * @param bool $disconnect
     * @return string Return output XML.
     */
    public function sendXml($inputXml, $disconnect=false)
    {
        return $this->ExecuteProgram($inputXml, $disconnect);
    }

    /**
     * factory pattern.
     *
     * @return XMLWrapper
     */
    protected function getXmlWrapper()
    {
        return new XMLWrapper(array('encoding' => $this->getOption('encoding')), $this);
    }

    /**
     *
     *
     * @param string $info can be 'joblog' (joblog and additional info) or 'conf' (if custom config info set up in PLUGCONF)
     * @param string $jobName
     * @param string $jobUser
     * @param string $jobNumber
     * @return bool|void
     */
    public function getDiagnostics($info = 'joblog', $jobName = '', $jobUser = '', $jobNumber = '')
    {
        $xmlWrapper = $this->getXmlWrapper();

        $inputXml = $xmlWrapper->diagnosticsXmlIn($info, $jobName, $jobUser, $jobNumber);

        // set stored procedure "plug"
        $this->verifyPLUGName();

        // send the XML, running the command
        $outputXml = $this->sendXml($inputXml, false);

        if ($outputXml) {
            $this->cpfErr = '0';
            $this->error = '';

            return $xmlWrapper->parseDiagnosticsXml($outputXml);
        } else {
            // error or no info
             $this->cpfErr = $xmlWrapper->getErrorCode();
             $this->error = $this->cpfErr; // ->error is ambiguous. Include for backward compat.
             $this->errorText = $xmlWrapper->getErrorMsg();
             return false;
        }
                // get status: error or success, with a real CPF error message, and set the error code/msg.
//        $successFlag = $this->XMLWrapper->getCmdResultFromXml($outputXml, $parentTag);
    }

    /**
     * Return version number of the PHP toolkit (front-end).
     *
     * @return string Version number (e.g. '1.4.0')
     */
    public static function getFrontEndVersion()
    {
        return self::VERSION;
    }

    /**
     * return version number of XMLSERVICE. Not static because must connect to back-end
     * to get the version number.
     *
     * @return string Version
     */
    public function getBackEndVersion()
    {
        $diagnostics = $this->getDiagnostics();

        if (!$diagnostics['version']) {
            return false;
        }

        return $diagnostics['version'];
    }

    /**
     * Return version number of the local installation of XMLSERVICE, if available.
     * Static because don't have to connect or instantiate toolkit object.
     * Uses 'exec' command to retrieve local version number.
     * Requires 1.8.0+ of XMLSERVICE and new program introduced with it: xmlver.pgm.
     *
     * @param $library
     * @return string Version number (e.g. '1.8.0')
     */
    public static function getLocalBackEndVersion($library)
    {
        $cmd = "qsh -c /qsys.lib/$library.lib/xmlver.pgm";

        // will return false on error, or the version number if successful.
        // Note: the web server user must have permissions to the XMLVER program.
        $version = exec($cmd); // exec() returns last line of output from command

        // if unable to get version
        if (!$version) { // false or empty
            return "Cannot get version number for XMLSERVICE in library '$library' using program XMLVER. Check the library, permissions of the web server user, and that XMLSERVICE is at least v1.8.0+, when XMLVER was introduced.";
        }

        return $version;
    }

    /**
     * CLCommand
     *
     * @param array $command string will be turned into an array
     * @param string $exec could be 'pase', 'pasecmd', 'system,' 'rexx', or 'cmd'
     * @return array|bool
     */
    public function CLCommand($command, $exec = '')
    {
        $this->XMLWrapper = new XMLWrapper(array('encoding' => $this->getOption('encoding')), $this);

        $this->cpfErr = '0';
        $this->error = '';
        $this->errorText = '';

        $inputXml = $this->XMLWrapper->buildCommandXmlIn($command, $exec);

        // rexx and pase are the ways we might get data back.
        $expectDataOutput = in_array($exec, array('rexx', 'pase', 'pasecmd'));

        // if a PASE command is to be run, the tag will be 'sh'. Otherwise, 'cmd'.
        if ($exec == 'pase' || $exec == 'pasecmd') {
            $parentTag = 'sh';
        } else {
            $parentTag = 'cmd';
        }

        $this->VerifyPLUGName();

        // send the XML, running the command
        $outputXml = $this->sendXml($inputXml, false);

        // get status: error or success, with a real CPF error message, and set the error code/msg.
        $successFlag = $this->XMLWrapper->getCmdResultFromXml($outputXml, $parentTag);

        if ($successFlag) {
            $this->cpfErr = '0';
            $this->error = '';
        } else {
            $this->cpfErr = $this->XMLWrapper->getErrorCode();
            $this->error = $this->cpfErr; // ->error is ambiguous. Include for backward compat.
            $this->errorText = $this->XMLWrapper->getErrorMsg();
        }

        if ($successFlag && $expectDataOutput) {
            // if we expect to receive data, extract it from the XML and return it.
            $outputParamArray = $this->XMLWrapper->getRowsFromXml($outputXml, $parentTag);

            unset($this->XMLWrapper);
            return $outputParamArray;
        } else {
            // don't expect data. Return true/false (success);
            unset($this->XMLWrapper);
            return $successFlag;
        }
    }

    /**
     * @param $command
     * @return array|bool
     */
    public function CLInteractiveCommand($command)
    {
        return $this->CLCommand($command, 'pase');
    }

    /**
     * @param $command
     * @return array|bool
     */
    public function paseCommand($command)
    {
        return $this->CLCommand($command, 'pasecmd');
    }

    /**
     * @param $command
     * @return bool
     */
    public function qshellCommand($command)
    {
        // send a command through the QSH interpreter
        // and interpret error results.

        // Handle errors and combine array-based results into a single string.

        // @todo consider doubling user-supplied single quotes to escape them in QSH

        $qshCommand = "QSH CMD('$command')";

        // will return an array of results.
        $resultArray = $this->CLInteractiveCommand($qshCommand);

        if (empty($resultArray) || !is_array($resultArray)) {
            logThis("Result of QSH command $qshCommand is empty or not an array.");
            return false;
        }

        // get status line
        $firstLine = trim($resultArray[0]);

        /* possible first line:
         * QSH0005: Command ended normally with exit status 0. [means A-OK]
         * QSH0005: Command ended normally with exit status 1. [look for a CPF message in next line]
         * QSH0005: Command ended normally with exit status 127. [problem finding command]
         * QSH0006: Command was ended by signal number yyy
         * QSH0007: Command was ended by an exception [haven't seen this one yet]
        */

        $qshCode = substr($firstLine, 0, 7);

        switch ($qshCode) {
            case 'QSH0005':
                /* get status code.
                 * String will be something like QSH0005: Command ended normally with exit status 1.
                 * But in German, QSH0005: Befehl wurde normal mit Ausfuehrungsstatus 1 beendet.
                 * Look for a number between two word boundaries (\b is word boundary).
                 * The word boundary (\b) is zero-length, so only the digits will be captured by the regex.
                 */
                $pattern = '/(\b[\d]+\b)/';
                // look for a match
                $numMatches = preg_match($pattern, $firstLine, $matches);

                if ($numMatches) {
                    $exitStatus = $matches[1]; // replacement parenthetical bit, i.e. the number.
                } else {
                    $this->cpfErr = $qshCode;
                    $this->error = 'Could not get exit code. Check toolkit error log for error.';
                    logThis("Result of QSH command $qshCommand was error: $firstLine.");
                    return false;
                }

                if ($exitStatus == '0') {
                    // SUCCESS!!!
                    // everything is fine.
                    // Return the rest of the array (without the status line).
                    if (count($resultArray) > 1) {
                        return array_slice($resultArray, 1);
                    }
                } else {
                    // Look for a CPF code in second line, although the second line may not be there, nor may the CPF, depending on the error.
                    // Second line will resemble: catsplf: 001-2003 Error CPF3492 found processing spool file QSYSPRT, number 2.
                    // or: catsplf: 001-2373 Job 579272/QTMHHTP1/WSURVEY400 was not found."
                    //
                    // @todo extract CPF code.
                    // @todo distinguish between status 1 and 127, if helpful
                    if (isset($resultArray[1])) {
                        $secondLine = trim($resultArray[1]);
                        $this->cpfErr = $secondLine;
                    }
                    // A nonzero exit status indicates failure, even when there is no second line of output.
                    // To test this principle, pass in the command "false", which always fails, but provides no second line of output.  
                    return false;
                }
                /*} elseif ($exitStatus == '127') {
                    // look for errmsg in second line (e.g. cannot find command)
                } //(if $exitStatus)
                */
                break;

            case 'QSH0006':
            case 'QSH0007':
                $this->cpfErr = $qshCode;
                $this->error = 'Check toolkit error log for error.';
                logThis("Result of QSH command $qshCommand was error: $firstLine.");
                return false;
                break;
        }

        return true;
    }

    /**
     * new. uses REXX to return output params and CPF codes
     * Slower than 'cmd' or 'system'
     *
     * Sample format of command: 'RTVJOBA JOB(?) USER(?) NBR(?) CURUSER(?) SYSLIBL(?) CURLIB(?) USRLIBL(?) LANGID(?) CNTRYID(?) CCSID(?N) DFTCCSID(?N)'
     *
     * @param $command
     * @return array|bool
     */
    public function ClCommandWithOutput($command)
    {
        return $this->CLCommand($command, 'rexx');
    }

    /**
     * new. uses 'system' to return CPF codes
     * slightly slower than regular cmd but faster than rexx
     * (Actually it's faster than cmd in recent tests. It depends, perhaps.)
     *
     * @param string $command can be a string or an array.
     * @return array|bool
     */
    public function ClCommandWithCpf($command)
    {
        return $this->CLCommand($command, 'system');
    }

    /**
     * @param $type
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param string $varying
     * @param int $dimension
     * @return array
     */
    public static function AddParameter($type, $io, $comment, $varName = '', $value = '', $varying = 'off', $dimension = 0)
    {
        return array ('type' => $type, // storage
                      'io' => $io, // in/out/both
                      'comment' => $comment, // comment
                      'var' =>  $varName, // variable name
                      'data' => $value, // value
                      'varying' => $varying, // varying on/varying off
                      'dim' =>   $dimension);// number of array elements
    }

    /**
     * @param $io
     * @param $size
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param string $varying
     * @param int $dimension
     * @param string $by
     * @param bool $isArray
     * @param string $ccsidBefore
     * @param string $ccsidAfter
     * @param bool $useHex
     * @return CharParam
     */
    public static function AddParameterChar($io, $size , $comment, $varName = '', $value= '', $varying = 'off',$dimension = 0,
                                      $by='', $isArray = false, $ccsidBefore = '', $ccsidAfter = '', $useHex = false)
    {
        return new CharParam($io, $size , $comment, $varName, $value , $varying , $dimension, $by,
                                    $isArray, $ccsidBefore, $ccsidAfter, $useHex);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return Int32Param
     */
    public static function AddParameterInt32($io, $comment, $varName = '', $value = '', $dimension = 0)
    {
        return new Int32Param($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $comment
     * @param string $varName
     * @param $labelFindLen
     * @return SizeParam
     */
    public static function AddParameterSize($comment, $varName = '', $labelFindLen = 0)
    {
        return new SizeParam($comment, $varName, $labelFindLen);
    }

    /**
     * @param $comment
     * @param string $varName
     * @param $labelFindLen
     * @return SizePackParam
     */
    public static function AddParameterSizePack($comment, $varName = '', $labelFindLen = 0)
    {
        return new SizePackParam($comment, $varName, $labelFindLen);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return Int8Param
     */
    public static function AddParameterInt8($io, $comment, $varName='', $value='', $dimension=0)
    {
        return new Int8Param($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return Int16Param
     */
    public static function AddParameterInt16($io, $comment, $varName='', $value='', $dimension=0)
    {
        return new Int16Param($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return Int64Param
     */
    public static function AddParameterInt64($io, $comment, $varName = '', $value = '', $dimension = 0)
    {
        return new Int64Param($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return UInt8Param
     */
    public static function AddParameterUInt8($io, $comment, $varName='', $value='', $dimension=0)
    {
        return new UInt8Param($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return UInt16Param
     */
    public static function AddParameterUInt16($io, $comment, $varName='', $value='', $dimension=0)
    {
        return new UInt16Param($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return UInt32Param
     */
    public static function AddParameterUInt32($io, $comment, $varName = '', $value = '', $dimension =0)
    {
        return new UInt32Param($io, $comment, $varName, $value, $dimension) ; // removed erroneous "off"
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return UInt64Param
     */
    public static function AddParameterUInt64($io, $comment, $varName = '', $value='', $dimension=0)
    {
        return new UInt64Param($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return FloatParam
     */
    public static function AddParameterFloat($io, $comment, $varName = '', $value='', $dimension=0)
    {
        return(new FloatParam($io, $comment, $varName, $value, $dimension));
    }

    /**
     * @param $io
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return RealParam
     */
    public static function AddParameterReal($io, $comment, $varName = '', $value='', $dimension=0)
    {
        return new RealParam($io, $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $length
     * @param $scale
     * @param $comment
     * @param string $varName
     * @param mixed $value
     * @param int $dimension
     * @return PackedDecParam
     */
    public static function AddParameterPackDec($io, $length ,$scale , $comment, $varName = '', $value='', $dimension=0)
    {
        return new PackedDecParam($io, $length ,$scale , $comment, $varName, $value, $dimension);
    }

    /**
     * @param $io
     * @param $length
     * @param $scale
     * @param $comment
     * @param string $varName
     * @param mixed $value
     * @param int $dimension
     * @return ZonedParam
     */
    public static function AddParameterZoned($io, $length ,$scale , $comment, $varName = '', $value='', $dimension=0)
    {
        return new ZonedParam($io, $length ,$scale , $comment, $varName , $value, $dimension);
    }

    /**
     * "hole" parameter is for data to ignore
     *
     * @param $size
     * @param string $comment
     * @return HoleParam
     */
    public static function AddParameterHole($size , $comment='hole')
    {
        return new HoleParam($size, $comment);
    }

    /**
     * @param $io
     * @param $size
     * @param $comment
     * @param string $varName
     * @param string $value
     * @param int $dimension
     * @return BinParam
     */
    public static function AddParameterBin($io, $size , $comment, $varName = '', $value='',$dimension =0)
    {
        return new BinParam($io, $size , $comment, $varName, $value,$dimension);
    }

    /**
     * @param $array
     * @return array
     */
    public static function AddParameterArray($array)
    {
        $params = array();

        foreach ($array as $element) {
            $params[] = self::AddParameter($element['type'],
                                           $element['io'],
                                           $element['comment'],
                                           $element['var'],
                                           $element['data'],
                                           $element['varying'],
                                           $element['dim']);
        }

        return $params;
    }

    /**
     * @param array $parameters
     * @param string $name
     * @param int $dim
     * @param string $by
     * @param bool $isArray
     * @param int|null $labelLen
     * @param string $comment
     * @param string $io
     * @return DataStructure
     */
    public static function AddDataStruct(array $parameters, $name='struct_name', $dim=0, $by='', $isArray=false, $labelLen = null, $comment = '', $io = 'both')
    {
        return new DataStructure($parameters, $name, $dim, $comment, $by, $isArray, $labelLen, $io);
    }

    /**
     * @return DataStructure
     */
    public static function AddErrorDataStruct()
    {
        return new DataStructure(self::GenerateErrorParameter(), 'errorDs', 0);
    }

    /**
     * use this one when you need a zero-byte error structure, which is useful to
     * force errors to bubble up to joblog, where you can get more information than
     * in the structure.
     *
     * @return DataStructure
     */
    public static function AddErrorDataStructZeroBytes()
    {
        return new DataStructure(self::GenerateErrorParameterZeroBytes(), 'errorDs', 0);
    }

    // pure XML version
    // Pass in $paramNum to get a numeric parameter number for the comment.
/*    static function getErrorDataStructXml($paramNum = 0) {
        $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';
        return "<parm io='both' comment='$paramNumStr Error code structure'>
                 <ds var='errorDs'>
                   <data var='errbytes' type='10i0' comment='Size of DS'>144</data>
                   <data var='err_bytes_avail' type='10i0' comment='if non-zero, an error occurred' />
                   <data var='exceptId' type='7A' varying='off' comment='CPF code'>0000000</data>
                   <data var='reserved' type='1h' varying='off' />
                   <data var='excData' type='128a' varying='off' comment='replacement data. Not sure we want it.  Causes problems in XML (binary data in there?).' />
                 </ds>
              </parm>";
    }
*/
    // use a zero (0) bytes length to force errors to bubble up to job. It's easier for us to get full message text from joblog that XMLSERVICE toolkit provides.
    // Anyway, the QSNDDTAQ API doesn't have an error struct, so this way we can be consistent---get all errors in joblog.

    /**
     * @param int $paramNum
     * @return string
     */
    public static function getErrorDataStructXml($paramNum = 0)
    {
        $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

        return "<parm io='both' comment='$paramNumStr Error code structure'>
                 <ds var='errorDs'>
                   <data var='errbytes' type='10i0' comment='Size of DS. Use 0 to force errors to bubble up to the job'>0</data>
                 </ds>
              </parm>";
    }

    /**
     * This version will provide the error code in output rather than forcing errors to bubble up to joblog.
     * Since XMLSERVICE is slow at getting job log, it's faster to get the code in the API DS if available.
     * Pass in $paramNum to get a numeric parameter number for the comment.
     *
     * @param int $paramNum
     * @return string
     */
    public static function getErrorDataStructXmlWithCode($paramNum = 0)
    {
        $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

        return "<parm io='both' comment='$paramNumStr Error code structure'>
            <ds var='errorDs'>
            <data var='errbytes' type='10i0' comment='Size of DS'>16</data>
            <data var='err_bytes_avail' type='10i0' comment='if non-zero, an error occurred' />
            <data var='exceptId' type='7A' comment='CPF code'>0000000</data>
            <data var='reserved' type='1h' />
            </ds>
            </parm>";
    }

    /**
     * this DS is common to many IBM i APIs.
     *
     * @param int $paramNum
     * @return string
     */
    public static function getListInfoApiXml($paramNum = 0)
    {
        $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

        return "<parm io='out' comment='$paramNumStr List information'>
            <ds var='listinfo' comment='Open list information format (common to all lists)'>
             <data var='totalRecords' comment='Total records' type='10i0' />
             <data var='returnedRecords' comment='Records returned' type='10i0' />
             <data var='requestHandle' comment='Request handle: binary/hex' type='4b' />
             <data var='recordLength' comment='Record length' type='10i0' />
             <data var='infoComplete' comment='Information complete indicator. C=complete, I=incomplete, P=partial, more to get in Get List Entries' type='1a' />
             <data var='timeAndDateCreated' comment='Time and date created' type='13a' />
             <data var='listStatus' comment='List status indicator' type='1a' />
             <data var='reserved' comment='Reserved' type='1h' />
             <data var='lengthReturned' comment='Length of information returned' type='10i0' />
             <data var='firstRecordNumber' comment='Number of first record returned in receiver variable' type='10i0' />
             <data var='reserved2' comment='Reserved (another one)' type='40h' />
            </ds>
          </parm>";
    }

    /**
     * this DS is common to many IBM i APIs.
     *
     * @param int $paramNum
     * @return string
     */
    public static function getNumberOfRecordsDesiredApiXml($paramNum = 0)
    {
        $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

        return "<parm io='in' comment='$paramNumStr Number of records to return. Use zero to offload to Get List Entries API'>
                  <data var='numRecsDesired' type='10i0'>0</data>
                </parm>";
    }

    /**
     * this DS is common to many IBM i APIs.
     *
     * @param int $paramNum
     * @return string
     */
    public static function getSortInformationApiXml($paramNum = 0)
    {
        $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

        // assume no sort is required. Could add a sort in future if needed.
        return "<parm io='in' comment='$paramNumStr Sort information' >
                 <ds var='sortInfo'>
                   <data var='numSortKeys' comment='Number of keys to sort on. Use zero' type='10i0'>0</data>
                 </ds>
               </parm>";
    }

    /**
     * this DS is common to many IBM i APIs.
     *
     * @param int $paramNum
     * @param $lengthOfReceiverVariable
     * @return string
     */
    public static function getDummyReceiverAndLengthApiXml($paramNum, $lengthOfReceiverVariable)
    {
        $paramNumStr = $paramNum . '.';
        $paramNumStrNext = ($paramNum + 1) . '.';

        // assume no sort is required. Could add a sort in future if needed.
        return "<parm io='out' comment='$paramNumStr receiver. do not actually receive anything here. Wait till Get List Entry'>
                  <ds var='receiver' comment='length $lengthOfReceiverVariable'>
                    <data type='1h' comment='dummy. Real receiver will be gotten in list entry API call' />
                  </ds>
                </parm>
                <parm io='in' comment='$paramNumStrNext Length of receiver variable (actual structure to be given in Get List Entry)'>
                  <data var='receiverLen' type='10i0' comment='length $lengthOfReceiverVariable'>$lengthOfReceiverVariable</data>
                </parm>";
    }

    /**
     * @return string
     */
    public function getLastError()
    {
        return $this->error;
    }

    /**
     * @return bool
     */
    public function isError()
    {
        if ($this->error != '') {
            return true;
        }

        return false;
    }

    /**
     * @return bool|void
     */
    public function getInternalKey()
    {
        return $this->getOption('internalKey');
    }

    /**
     * @return bool|void
     */
    public function isStateless()
    {
        return $this->getOption('stateless');
    }

    /**
     * @param $internalKey
     */
    public function setInternalKey($internalKey)
    {
        $this->setOptions(array('internalKey' => $internalKey));
    }

    /**
     * construct a string of space-delimited control keys based on properties of this class.
     *
     * @param bool $disconnect
     * @return string
     */
    protected function getControlKey($disconnect = false)
    {
        $key = '';

        if ($disconnect) {
            return "*immed";
        }

        /*
        if(?) *justproc
        if(?) *debug
        if(?) *debugproc
        if(?) *nostart
        if(?) *rpt*/

        // Idle timeout supported by XMLSERVICE 1.62
        // setting idle for *sbmjob protects the time taken by program calls
        // Do that with *idle(30/kill) or whatever the time in seconds.
        if (trim($this->getOption('idleTimeout')) != '') {
            $idleTimeout = $this->getOption('idleTimeout');
            $key .= " *idle($idleTimeout/kill)"; // ends idle only, but could end MSGW with *call(30/kill)
        }

        // if cdata requested, request it. XMLSERVICE will then wrap all output in CDATA tags.
        if ($this->getOption('cdata')) {
            $key .= " *cdata";
        }

        /* stateless calls in stored procedure job
         *
         * Add *here, which will run everything inside the current PHP/transport job
         * without spawning or submitting a separate XTOOLKIT job.
         */
        if ($this->isStateless()) {
            $key .= " *here";
        } else {
            // not stateless, so could make sense to supply *sbmjob parameters for spawning a separate job.
            if (trim($this->getOption('sbmjobParams')) != '') {
               $sbmjobParams = $this->getOption('sbmjobParams');
               $key .= " *sbmjob($sbmjobParams)";
            }
        }

        // if internal XMLSERVICE tracing, into database table XMLSERVLOG/LOG, is desired
        if ($this->getOption('trace')) {
            $key .= " *log";
        }

        // directive not to run any program, but to parse XML and return parsed output, including dim/dou.
        if ($this->getOption('parseOnly')) {
            $key .= " *test";

            // add a debugging level (1-9) to the parse, to make *test(n) where n is the debugging level
            if ($parseDebugLevel = $this->getOption('parseDebugLevel')) {
                $key .= "($parseDebugLevel)";
            }
        }

        // return XMLSERVICE version/license information (no XML calls)
        if ($this->getOption('license')) {
            $key .= " *license";
        }

        // check proc call speed (no XML calls)
        if ($this->getOption('transport')) {
            $key .= " *justproc";
        }

        // get performance of last call data (no XML calls)
        if ($this->getOption('performance')) {
            $key .= " *rpt";
        }

        // *fly is number of ticks of each operation. *nofly is the default
        if ($this->getOption('timeReport')) {
            $key .= " *fly";
        }

        // PASE CCSID for <sh> type of functions such as WRKACTJOB ('system' command in PASE)
        if ($paseCcsid = $this->getOption('paseCcsid')) {
            $key .= " *pase($paseCcsid)";
        }

        // allow custom control keys
        if ($this->getOption('customControl')) {
            $key .= " {$this->getOption('customControl')}";
        }

        return trim($key); // trim off any extra blanks on beginning or end
    }

    /**
     * to set a plug name use function setToolkitServiceParams('plug'=>'iPLUGR512K')
     */
    protected function VerifyPLUGName()
    {
        // if plug already set, don't need to set it now.
        if ($this->getOption('plug') != '') {
            return;
        }

        //Sets the default plug.
        $size = 512;
        $unit = 'K';//or M

        /*4K, 32K, 65K, 512K,
          1M, 5M, 10M up to 15M ...*/

        //in case that following SQL error error:
        //Length in a varying-length or LOB host variable not valid. SQLCODE=-311
        //verify that all last blob ptfs are applied on i5 machine
        //set the $this->plug = "iPLUG4K";,
        //it calls the program that returns data via char storage
        $plug = $this->getOption('plugPrefix') . $size . $unit;
        $this->setOptions(array('plug' => $plug));
    }

    /**
     * Ensures that an IPC has been set. If not, generate one
     */
    protected function verifyInternalKey()
    {
        // if we are running in stateless mode, there's no need for an IPC key.
        if ($this->isStateless()) {
            $this->setInternalKey('');
              return;
        }

        if (trim($this->getInternalKey()) == '') {
            if (session_id() != '') { /*if programmer already started session, use it*/
                $this->setInternalKey("/tmp/" . session_id());
            } else {
                $this->setInternalKey("/tmp/". $this->generate_name());
            }
        }
    }

    /**
     * was protected. Changed to public.
     * May be useful to access raw XML result
     * @todo make outputXml a property that is used so this method can work.
     *
     * @return mixed
     */
    public function getXmlOut() {
        return $this->outputXml;
    }

    /**
     * return transport object for toolkit
     *
     * @return null|resource
     */
    public function getConnection()
    {
      return $this->conn;
    }

    /**
     * @return string
     */
    public function generate_name()
    { /*move to i5 side*/
        $localtime = localtime();
        $rndName = sprintf("ZS%d%d%d%d",
                     $localtime[0],/*s*/
                     $localtime[1],/*min*/
                     $localtime[2],/*hour*/
                     $localtime[3] /*day*/
                      );
        return $rndName;
    }

    /**
     * creates Data structure that going to be used in lot of
     * i5 API's for error handling
     *
     * @return array
     */
    public static function GenerateErrorParameter()
    {
        $ErrBytes   = 144;
        $ErrBytesAv = 144;
        $ErrCPF     = '0000000';
        $ErrRes     = ' ';
        $ErrEx      = ' ';
        // changed $this to self so can work in static context
        $ds[] = self::AddParameterInt32('in', "Bytes provided", 'errbytes', $ErrBytes);
        $ds[] = self::AddParameterInt32('out', "Bytes available",'err_bytes_avail', $ErrBytesAv);
        $ds[] = self::AddParameterChar('out',7, "Exception ID", 'exceptId', $ErrCPF);
        $ds[] = self::AddParameterChar('out',1, "Reserved", 'reserved', $ErrRes);
        $ds[] = self::AddParameterHole('out',128, "Exception data", 'excData', $ErrEx); // can be bad XML so make it a hole
        return $ds;
    }

    /**
     * specify zero bytes so error bubbles up to joblog where we can get description, etc.
     *
     * @todo return 'in'-only data structure containing the int.
     *
     * @return array
     */
    public static function GenerateErrorParameterZeroBytes()
    {
        $ErrBytes   = 0;
        // changed $this to self so can work in static context
        $ds[] = self::AddParameterInt32('in', "Bytes provided (zero makes errors bubble up to joblog)", 'errbytes', $ErrBytes);
        return $ds;
    }

    /**
     * @param $retPgmArr
     * @param $functionErrMsg
     * @return bool
     */
    public function verify_CPFError($retPgmArr, $functionErrMsg)
    {
        // it's an error if we didn't get output array at all
        // in that case, look for general "error" material

        // $functionErrMsg is obsolete now.

        if (!is_array($retPgmArr)) {
            $this->error = $this->getLastError();
            return true;
        }

        $retArr = $retPgmArr['io_param'];

        // get errorDs from named ds (CW style) or directly (PHP toolkit style)
        $errorDs = (isset($retArr['errorDs'])) ? $retArr['errorDs'] : $retArr;

        // If there's an error structure and some error info was returned.
        // (err_bytes_avail is the official, reliable way to check for an error.)
        if (isset($errorDs) && ($errorDs['err_bytes_avail'] > 0)) {
            $this->cpfErr = $errorDs['exceptId'];
            // @todo future, get actual error text from joblog
            $this->error = $functionErrMsg;
            return true; //some problem
        } else {
            // no CPF error detected.
            $this->cpfErr = '0000000';
            $this->error = '';
            return false;
        }
    }

    /**
     * err_bytes_avail is the official, reliable way to check for an error.
     *
     * @todo should this be using $this->cpfErr
     *
     * @param array $Error
     * @return bool
     */
    public function ParseErrorParameter(array $Error)
    {
        $CPFErr = false;
        if (!is_array($Error)) {
            return false;
        }

        // If there's an error structure and some error info was returned.
        if (isset($Error['exceptId']) && ($Error['err_bytes_avail'] > 0)) {
            $CPFErr = $Error['exceptId'];
        }

        return $CPFErr;
    }

    /**
     * for sql calls via already opened connection.
     * Clearer naming than existing getConnection();
     *
     * @todo Probably even better would be a name such as getTransportConn() because it could work for any transport type.
     *
     * @return null|resource
     */
    public function getSQLConnection()
    {
        return $this->getConnection();
    }

    /**
     * @param $stmt
     * @return mixed
     * @throws \Exception
     */
    public function executeQuery($stmt)
    {
        $Txt = $this->db->executeQuery($this->getConnection(), $stmt);

        if (!is_array($Txt)) {
            $this->cpfErr = $this->db->getErrorCode();
            $this->error = $this->db->getErrorMsg();

            throw new \Exception($this->error, (int)$this->cpfErr);
        }

        return $Txt;
    }

    /**
     * @param bool $isPersistent
     * @throws \Exception
     */
    public function setIsPersistent($isPersistent = false)
    {
        if (is_bool($isPersistent)) {
            $this->_isPersistent = $isPersistent;
        } else {
            throw new \Exception("setIsPersistent: boolean expected");
        }
    }

    /**
     * @return bool
     */
    public function getIsPersistent()
    {
        return $this->_isPersistent;
    }

    /**
     * Method: getJobAttributes()
     *
     * Retrieve several attributes of the current job.
     * Purpose: 1. Helps user find toolkit job; identifies libraries and CCSID used by toolkit connection
     *          2. The code is an example of how to get output from RTV* CL commands
     * Sample output:
     * Array(
     *     [JOB] => QSQSRVR
     *     [USER] => QUSER
     *     [NBR] => 240164
     *     [CURUSER] => QTMHHTTP
     *     [SYSLIBL] => QSYS       QSYS2      QHLPSYS    QUSRSYS    DBU80      QSYS38
     *     [CURLIB] => *NONE
     *     [USRLIBL] => QTEMP      QGPL       MYUTIL
     *     [LANGID] => ENU
     *     [CNTRYID] => US
     *     [CCSID] => 37
     *     [DFTCCSID] => 37)
     *
     * @return array|bool array of attributes (key/value pairs) or false if unsuccessful.
     */
    public function getJobAttributes()
    {
        // Retrieve job attributes. Note: the CCSID attributes use (?N), not (?), because they are numeric.
        $cmdString = 'RTVJOBA JOB(?) USER(?) NBR(?) CURUSER(?) SYSLIBL(?) CURLIB(?) USRLIBL(?) LANGID(?) CNTRYID(?) CCSID(?N) DFTCCSID(?N)';

        // Send the command; get output array of key/value pairs. Example: CURUSER=>FRED, ...
        $outputArray = $this->ClCommandWithOutput($cmdString);

        return $outputArray;
    }

    /**
     * classPath(). for diagnostics, return the file system absolute path of this script.
     * Usage: echo 'The path of ToolkitService.php is: ' . ToolkitService::classPath();
     * Sample output: The path of ToolkitService.php is: /usr/local/zendsvr6/share/ToolkitApiDev-1.4.0/pre140/ToolkitService.php
     *
     * @return string
     */
    public static function classPath()
    {
        return __FILE__;
    }

    /**
     * given $this->joblog, and an array of program names that might have caused errors,
     * extract the error code (CPF or similar) and message text from the joblog.
     *
     * Include '< lveContext' because it may appear in the program spot if library does not exist.
     * '#mnrnrl' if program does not exist.
     * 'QRNXIE' for non-numeric data passed in numeric field.
     * '< allProgram' for when wrong number of params are passed.
     *
     * @todo instead of all these pseudo-program names, take last error from XMLSERVICE parsing, if program name itself not found.
     *
     * If can't find error in joblog, uses UNEXPECTED and text from $this->XMLWrapper->getLastError();
     *
     * Code is placed in $this->cpfErr. Text goes to $this->error.
     *
     * @param array $programsToLookFor
     * @return boolean True on success, False on failure
     */
    protected function extractErrorFromJoblog(array $programsToLookFor)
    {
        // CPF, CPC, CPE...
        // also get between
        /*Message . . . . :   Invalid length. MAXLEN for data queue NEWQ in CWDEMO is
         128.
        Cause . . . . . :  */

        // where we can find info in joblog
        $cpfOffset = 0; // first 7 chars is CPF
        $cpfLen = 7;

        $pgmOffset = 67; // program name found on same line as CPF code, offset 68
        $pgmLen = 12; // can be special '< lveContext' type names.

        $messageLabel = 'Message . . . . :';
        $messageLabelOffset = 37; // "Message . . . . :   "
        $messageLabelLen = strlen($messageLabel);

        $causeLabel = 'Cause . . . . . :';
        $recoveryLabel = 'Recovery  . . . :';

        // split on line feeds, then put in reverse order so that we'll get the latest first
        $joblogLines = $lines = preg_split('/\r\n|\r|\n/', $this->joblog); // split on 0D0A etc.

        // in reverse order, look for line with program given/
        // "true" in array_reverse() keeps array index/record numbers intact.
        $startingLine = 0;
        foreach (array_reverse($joblogLines, true) as $lineNum=>$lineString) {

            // Look for program name that we originally called.
            // Trim spaces from the right but not the left. (Need pgm name to START in precise location)
            $substringAtProgramLocation = rtrim(substr($lineString, $pgmOffset, $pgmLen));

            if (in_array($substringAtProgramLocation, $programsToLookFor)) {
                $startingLine = $lineNum;
                break;
            }
        }

        if ($startingLine) {
            // we found a joblog entry for the program that we called.

            // first line of section has CPF code as well as program name.
            $firstLine = $joblogLines[$startingLine];

            // get the error code. We call it CPF but it could also be GUI, CPE, CPC....
            $cpfCode = substr($firstLine, $cpfOffset, $cpfLen);

            // go forward till we hit the end or till we come to a new CPF code (detect that if find a fully 7-position string at start)
            $msgText = '';
            $startCollecting = false;
            // get rid of lines before starting line
            $joblogLines = array_slice($joblogLines, $startingLine);
            while (($lineString = next($joblogLines)) && ($lineString !== false) && (strpos($lineString, ' ', $cpfOffset) < $cpfLen)) {

                // but start collecting text when we find "Message" label.
                if (substr($lineString, $messageLabelOffset, $messageLabelLen) == $messageLabel) {
                    $startCollecting = true;
                }

                if ($startCollecting) {
                    // If not a heading (omit headings)
                    /*
                    5761SS1 V6R1M0 080215                        Display Job Log                        SBSUSA   11/18/11 15:39:54          Page    2
                    Job name . . . . . . . . . . :   QSQSRVR         User  . . . . . . :   QUSER        Number . . . . . . . . . . . :   815166
                    Job description  . . . . . . :   QDFTSVR         Library . . . . . :   QGPL
                    MSGID      TYPE                    SEV  DATE      TIME             FROM PGM     LIBRARY     INST     TO PGM      LIBRARY     INST
                    */
                    $lineLen = strlen($lineString);

                    // Is a heading if one of the following are found. Use !== false because 0 is a valid "found" result.
                    // Check that line length is > 46 before checking for string in position 46, to avoid warning in log
                    $isHeadingLine = (($lineLen > 46 && (strpos($lineString, 'Display Job Log', 46) !== false)) ||
                            strpos($lineString, 'Job name', 2) !== false ||
                            strpos($lineString, 'Job description', 2) !== false ||
                            strpos($lineString, 'MSGID', 0) !== false);

                    if (!$isHeadingLine) {
                        // concatenate whole line. We will remove labels later
                       $msgText .= ' '. trim($lineString);
                    } //(if not a heading line)
                }
            }

            /**
             * Clean up $msgText.
             * Remove text labels and convert multiple spaces to single space
             */
            $old = array($messageLabel, $causeLabel, $recoveryLabel, '   ', '  ');
            $new = array('', '', '', ' ', ' ');
            $cleanMsgText = str_replace($old, $new, $msgText);

            $this->cpfErr = $cpfCode;
            $this->error = trim($cleanMsgText);
            $this->errorText = trim($cleanMsgText);
        } else {
            // could not find it.
            // use error text from XML parser (though this text is usually worthless)
            // @todo $this->cpfErr is expecting a 7 digit code, so this may be wrong
            $this->cpfErr = 'UNEXPECTED';
            $this->error = $this->XMLWrapper->getLastError();
            $this->errorText = $this->error;
        }

        return true;
    }

    /**
     * changeCurrentUser (1.5.0+)
     * Changes the current user of the job to a specific user. All actions will be executed as this user from now on.
     * Otherwise known as "swap user" or the misnomer "adopt authority."
     *
     * @param string $user Generally should be uppercase
     * @param string $password
     * @return boolean  True on success, False on failure
     */
    public function changeCurrentUser($user, $password)
    {
        // Force user/pw to uppercase. (should they?)
        // Ask Support team for opinion on uppercase or not.
        $user = strtoupper($user);
        $password = strtoupper($password);

        // Get profile handle (checking u/p validity)
        // http://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Fapis%2FQSYGETPH.htm
        $apiPgm = 'QSYGETPH';
        $apiLib = 'QSYS';

        $pwLen = strlen($password);
        $pwCcsid = '-1'; // -1 means 37 or DFTCCSID depending on password level

        $params[] = $this->addParameterChar('in', 10, '1. user', 'user', $user);
        $params[] = $this->addParameterChar('in', 10, '2. password', 'pw', $password);
        $params[] = $this->addParameterBin('out', 12, '3. profile handle', 'handleOut');

        // use a zero (0) bytes length to force errors to bubble up to job. It's easier for us to get full message text from joblog that XMLSERVICE toolkit provides.
        // As well, the QSNDDTAQ API doesn't have an error struct, so this way we can be consistent---get all errors in joblog.
        $params[] = $this->addParameterInt32('both', 'Size of error DS. Use 0 to force errors to bubble up to the job',  'errbytes', '0');

        if (substr($password, 0, 1) != '*') {
            /* No asterisk at the start, so this is an attempt at a real password,
             * not a special pw value starting with an asterisk such as *NOPWD, *NOPWDCHK, or *NOPWDSTS.
             * Therefore, include pw len and CCSID, which must be omitted if pw is a special "*" value.
            */
            $params[] = $this->addParameterInt32('both', '5. length of password. Must be equal to the actual pw length.    ', 'pwLen', $pwLen);
            $params[] = $this->addParameterInt32('both', '6. CCSID of password', 'pwCcsid', $pwCcsid);
        }

        // now call the API, returning results.
        $retPgmArr = $this->PgmCall($apiPgm, $apiLib, $params, null);

        if ($this->getErrorMsg() || $this->getErrorCode()) {
            // problem--possibly user or password was wrong
            return false;
        }

        // get handle from API we called.
        if (isset($retPgmArr['io_param']['handleOut'])) {
            $handle = $retPgmArr['io_param']['handleOut']; // handleOut defined in XML above
        }

        // if anything went wrong
        if (!isset($handle) || empty($handle)) {
            return false;
        }

        // now set the user profile via the handle.
        // http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=%2Fapis%2FQWTSETP.htm
//        $apiPgm = 'QWTSETP'; // set profile
//        $apiLib = 'QSYS';

        // reset $params array for next API call
        $params = array();
        $params[] = $this->addParameterBin('in', 12, '1. profile handle', 'handleIn', $handle);
        // error ds param
        $params[] = $this->addParameterInt32('both', '2. Size of error DS. Use 0 to force errors to bubble up to the job',  'errbytes', '0');

        // any errors?
        if ($this->getErrorMsg() || $this->getErrorCode()) {
            // problem--possibly user or password was wrong
            return false;
        }

        // Now close/release the handle (handles are limited resources, about 20,000 per job).
        // http://publib.boulder.ibm.com/infocenter/iseries/v7r1m0/index.jsp?topic=%2Fapis%2FQSYRLSPH.htm
        $apiPgm = 'QSYRLSPH'; // release profile handle
        $apiLib = 'QSYS';

        // reset $params array for next API call
        $params = array();
        $params[] = $this->addParameterBin('in', 12, '1. profile handle', 'handleIn', $handle);
        // error ds param
        $params[] = $this->addParameterInt32('both', '2. Size of error DS. Use 0 to force errors to bubble up to the job',  'errbytes', '0');

        // now call the "release handle" API!
        $this->PgmCall($apiPgm, $apiLib, $params);

        // any errors?
        if ($this->getErrorMsg() || $this->getErrorCode()) {
            // problem--possibly user or password was wrong
            return false;
        }

        return true;
    }

    /**
     * return value from toolkit config file, or a default value, or false if not found.
     * method is static so that it can retain its value from call to call.
     *
     * @todo store in Zend Data Cache to avoid reading during each request
     *
     * @todo change getConfigValue to allow getting many at one time
     *
     * @param $heading
     * @param $key
     * @param mixed|null $default
     * @return bool|null
     */
    public static function getConfigValue($heading, $key, $default = null)
    {
        // if we haven't read config file yet, do so.
        if (!isset(self::$_config)) {
            // read/stat INI once and only once per request
            self::$_config = parse_ini_file(CONFIG_FILE, true);
        }

        if (isset(self::$_config[$heading][$key])) {
            return self::$_config[$heading][$key];
        } elseif (isset($default)) {
            return $default;
        } else {
            return false;
        }
    }

    /**
     * get operating system that PHP is running on static method so we don't have
     * to connect to IBM i to find out and to retain value from call to call
     *
     * @return string
     */
    public static function getPhpOperatingSystem() {

        if (!isset(self::$_os)) {
            self::$_os = php_uname('s');
        }

        return self::$_os;
    }

    /**
     * return true if PHP is running directly on IBM i, false if not.
     *
     * @return bool
     */
    public static function isPhpRunningOnIbmI()
    {
        return (self::getPhpOperatingSystem() == 'OS400');
    }

    /**
     * return the CCSID of PHP, whether defined in fastcgi or in PASE (php-cli).
     * if none defined then return false.
     *
     * @todo these static functions would be better placed in a separate "environment"
     * or utility class than here because they are not concerned with a particular
     * connection.
     *
     * @return bool
     */
    public static function getPhpCcsid()
    {
        if (isset($_SERVER['CCSID'])) {
            // web/fastcgi
            return $_SERVER['CCSID'];
        } elseif (isset($_SERVER['QIBM_PASE_CCSID'])) {
            // cli/pase
            return $_SERVER['QIBM_PASE_CCSID'];
        } else {
            return false;
        }
    }
}
